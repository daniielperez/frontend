import { EventEmitter, Component, Renderer2, ViewChild, Input, Output, NgModule, Injectable, ɵɵdefineInjectable } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CropperDrawSettings {
    /**
     * @param {?=} settings
     */
    constructor(settings) {
        this.lineDash = false;
        this.strokeWidth = 1;
        this.strokeColor = 'rgba(255,255,255,1)';
        this.fillColor = 'rgba(255,255,255,1)';
        this.dragIconStrokeWidth = 1;
        this.dragIconStrokeColor = 'rgba(0,0,0,1)';
        this.dragIconFillColor = 'rgba(255,255,255,1)';
        this.backgroundFillColor = 'rgba(0,0,0,0.6)';
        if (typeof settings === 'object') {
            this.lineDash = settings.lineDash || this.lineDash;
            this.strokeWidth = settings.strokeWidth || this.strokeWidth;
            this.fillColor = settings.fillColor || this.fillColor;
            this.strokeColor = settings.strokeColor || this.strokeColor;
            this.dragIconStrokeWidth =
                settings.dragIconStrokeWidth || this.dragIconStrokeWidth;
            this.dragIconStrokeColor =
                settings.dragIconStrokeColor || this.dragIconStrokeColor;
            this.dragIconFillColor =
                settings.dragIconFillColor || this.dragIconFillColor;
            this.backgroundFillColor =
                settings.backgroundFillColor || this.backgroundFillColor;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CropperSettings {
    /**
     * @param {?=} settings
     */
    constructor(settings) {
        this.canvasWidth = 300;
        this.canvasHeight = 300;
        this.dynamicSizing = false;
        this.width = 200;
        this.height = 200;
        this.minWidth = 50;
        this.minHeight = 50;
        this.minWithRelativeToResolution = true;
        this.croppedWidth = 100;
        this.croppedHeight = 100;
        this.cropperDrawSettings = new CropperDrawSettings();
        this.touchRadius = 20;
        this.noFileInput = false;
        this.markerSizeMultiplier = 1;
        this.centerTouchRadius = 20;
        this.showCenterMarker = true;
        this.allowedFilesRegex = /\.(jpe?g|png|gif|bmp)$/i;
        this.cropOnResize = true;
        this.preserveSize = false;
        this.compressRatio = 1.0;
        // tslint:disable-next-line:variable-name
        this._rounded = false;
        // tslint:disable-next-line:variable-name
        this._keepAspect = true;
        if (typeof settings === 'object') {
            Object.assign(this, settings);
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set rounded(val) {
        this._rounded = val;
        if (val) {
            this._keepAspect = true;
        }
    }
    /**
     * @return {?}
     */
    get rounded() {
        return this._rounded;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set keepAspect(val) {
        this._keepAspect = val;
        if (this._rounded === true && this._keepAspect === false) {
            console.error('Cannot set keep aspect to false on rounded cropper. Ellipsis not supported');
            this._keepAspect = true;
        }
    }
    /**
     * @return {?}
     */
    get keepAspect() {
        return this._keepAspect;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Fraction extends Number {
}
class Exif {
    constructor() {
        this.debug = false;
        this.IptcFieldMap = {
            0x78: 'caption',
            0x6e: 'credit',
            0x19: 'keywords',
            0x37: 'dateCreated',
            0x50: 'byline',
            0x55: 'bylineTitle',
            0x7a: 'captionWriter',
            0x69: 'headline',
            0x74: 'copyright',
            0x0f: 'category'
        };
        this.Tags = {
            // version tags
            0x9000: 'ExifVersion',
            // EXIF version
            0xa000: 'FlashpixVersion',
            // Flashpix format version
            // colorspace tags
            0xa001: 'ColorSpace',
            // Color space information tag
            // image configuration
            0xa002: 'PixelXDimension',
            // Valid width of meaningful image
            0xa003: 'PixelYDimension',
            // Valid height of meaningful image
            0x9101: 'ComponentsConfiguration',
            // Information about channels
            0x9102: 'CompressedBitsPerPixel',
            // Compressed bits per pixel
            // user information
            0x927c: 'MakerNote',
            // Any desired information written by the manufacturer
            0x9286: 'UserComment',
            // Comments by user
            // related file
            0xa004: 'RelatedSoundFile',
            // Name of related sound file
            // date and time
            0x9003: 'DateTimeOriginal',
            // Date and time when the original image was generated
            0x9004: 'DateTimeDigitized',
            // Date and time when the image was stored digitally
            0x9290: 'SubsecTime',
            // Fractions of seconds for DateTime
            0x9291: 'SubsecTimeOriginal',
            // Fractions of seconds for DateTimeOriginal
            0x9292: 'SubsecTimeDigitized',
            // Fractions of seconds for DateTimeDigitized
            // picture-taking conditions
            0x829a: 'ExposureTime',
            // Exposure time (in seconds)
            0x829d: 'FNumber',
            // F number
            0x8822: 'ExposureProgram',
            // Exposure program
            0x8824: 'SpectralSensitivity',
            // Spectral sensitivity
            0x8827: 'ISOSpeedRatings',
            // ISO speed rating
            0x8828: 'OECF',
            // Optoelectric conversion factor
            0x9201: 'ShutterSpeedValue',
            // Shutter speed
            0x9202: 'ApertureValue',
            // Lens aperture
            0x9203: 'BrightnessValue',
            // Value of brightness
            0x9204: 'ExposureBias',
            // Exposure bias
            0x9205: 'MaxApertureValue',
            // Smallest F number of lens
            0x9206: 'SubjectDistance',
            // Distance to subject in meters
            0x9207: 'MeteringMode',
            // Metering mode
            0x9208: 'LightSource',
            // Kind of light source
            0x9209: 'Flash',
            // Flash status
            0x9214: 'SubjectArea',
            // Location and area of main subject
            0x920a: 'FocalLength',
            // Focal length of the lens in mm
            0xa20b: 'FlashEnergy',
            // Strobe energy in BCPS
            0xa20c: 'SpatialFrequencyResponse',
            //
            0xa20e: 'FocalPlaneXResolution',
            // Number of pixels in width direction per FocalPlaneResolutionUnit
            0xa20f: 'FocalPlaneYResolution',
            // Number of pixels in height direction per FocalPlaneResolutionUnit
            0xa210: 'FocalPlaneResolutionUnit',
            // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution
            0xa214: 'SubjectLocation',
            // Location of subject in image
            0xa215: 'ExposureIndex',
            // Exposure index selected on camera
            0xa217: 'SensingMethod',
            // Image sensor type
            0xa300: 'FileSource',
            // Image source (3 == DSC)
            0xa301: 'SceneType',
            // Scene type (1 == directly photographed)
            0xa302: 'CFAPattern',
            // Color filter array geometric pattern
            0xa401: 'CustomRendered',
            // Special processing
            0xa402: 'ExposureMode',
            // Exposure mode
            0xa403: 'WhiteBalance',
            // 1 = auto white balance, 2 = manual
            0xa404: 'DigitalZoomRation',
            // Digital zoom ratio
            0xa405: 'FocalLengthIn35mmFilm',
            // Equivalent foacl length assuming 35mm film camera (in mm)
            0xa406: 'SceneCaptureType',
            // Type of scene
            0xa407: 'GainControl',
            // Degree of overall image gain adjustment
            0xa408: 'Contrast',
            // Direction of contrast processing applied by camera
            0xa409: 'Saturation',
            // Direction of saturation processing applied by camera
            0xa40a: 'Sharpness',
            // Direction of sharpness processing applied by camera
            0xa40b: 'DeviceSettingDescription',
            //
            0xa40c: 'SubjectDistanceRange',
            // Distance to subject
            // other tags
            0xa005: 'InteroperabilityIFDPointer',
            0xa420: 'ImageUniqueID' // Identifier assigned uniquely to each image
        };
        this.TiffTags = {
            0x0100: 'ImageWidth',
            0x0101: 'ImageHeight',
            0x8769: 'ExifIFDPointer',
            0x8825: 'GPSInfoIFDPointer',
            0xa005: 'InteroperabilityIFDPointer',
            0x0102: 'BitsPerSample',
            0x0103: 'Compression',
            0x0106: 'PhotometricInterpretation',
            0x0112: 'Orientation',
            0x0115: 'SamplesPerPixel',
            0x011c: 'PlanarConfiguration',
            0x0212: 'YCbCrSubSampling',
            0x0213: 'YCbCrPositioning',
            0x011a: 'XResolution',
            0x011b: 'YResolution',
            0x0128: 'ResolutionUnit',
            0x0111: 'StripOffsets',
            0x0116: 'RowsPerStrip',
            0x0117: 'StripByteCounts',
            0x0201: 'JPEGInterchangeFormat',
            0x0202: 'JPEGInterchangeFormatLength',
            0x012d: 'TransferFunction',
            0x013e: 'WhitePoint',
            0x013f: 'PrimaryChromaticities',
            0x0211: 'YCbCrCoefficients',
            0x0214: 'ReferenceBlackWhite',
            0x0132: 'DateTime',
            0x010e: 'ImageDescription',
            0x010f: 'Make',
            0x0110: 'Model',
            0x0131: 'Software',
            0x013b: 'Artist',
            0x8298: 'Copyright'
        };
        this.GPSTags = {
            0x0000: 'GPSVersionID',
            0x0001: 'GPSLatitudeRef',
            0x0002: 'GPSLatitude',
            0x0003: 'GPSLongitudeRef',
            0x0004: 'GPSLongitude',
            0x0005: 'GPSAltitudeRef',
            0x0006: 'GPSAltitude',
            0x0007: 'GPSTimeStamp',
            0x0008: 'GPSSatellites',
            0x0009: 'GPSStatus',
            0x000a: 'GPSMeasureMode',
            0x000b: 'GPSDOP',
            0x000c: 'GPSSpeedRef',
            0x000d: 'GPSSpeed',
            0x000e: 'GPSTrackRef',
            0x000f: 'GPSTrack',
            0x0010: 'GPSImgDirectionRef',
            0x0011: 'GPSImgDirection',
            0x0012: 'GPSMapDatum',
            0x0013: 'GPSDestLatitudeRef',
            0x0014: 'GPSDestLatitude',
            0x0015: 'GPSDestLongitudeRef',
            0x0016: 'GPSDestLongitude',
            0x0017: 'GPSDestBearingRef',
            0x0018: 'GPSDestBearing',
            0x0019: 'GPSDestDistanceRef',
            0x001a: 'GPSDestDistance',
            0x001b: 'GPSProcessingMethod',
            0x001c: 'GPSAreaInformation',
            0x001d: 'GPSDateStamp',
            0x001e: 'GPSDifferential'
        };
        this.StringValues = {
            ExposureProgram: {
                0: 'Not defined',
                1: 'Manual',
                2: 'Normal program',
                3: 'Aperture priority',
                4: 'Shutter priority',
                5: 'Creative program',
                6: 'Action program',
                7: 'Portrait mode',
                8: 'Landscape mode'
            },
            MeteringMode: {
                0: 'Unknown',
                1: 'Average',
                2: 'CenterWeightedAverage',
                3: 'Spot',
                4: 'MultiSpot',
                5: 'Pattern',
                6: 'Partial',
                255: 'Other'
            },
            LightSource: {
                0: 'Unknown',
                1: 'Daylight',
                2: 'Fluorescent',
                3: 'Tungsten (incandescent light)',
                4: 'Flash',
                9: 'Fine weather',
                10: 'Cloudy weather',
                11: 'Shade',
                12: 'Daylight fluorescent (D 5700 - 7100K)',
                13: 'Day white fluorescent (N 4600 - 5400K)',
                14: 'Cool white fluorescent (W 3900 - 4500K)',
                15: 'White fluorescent (WW 3200 - 3700K)',
                17: 'Standard light A',
                18: 'Standard light B',
                19: 'Standard light C',
                20: 'D55',
                21: 'D65',
                22: 'D75',
                23: 'D50',
                24: 'ISO studio tungsten',
                255: 'Other'
            },
            Flash: {
                0x0000: 'Flash did not fire',
                0x0001: 'Flash fired',
                0x0005: 'Strobe return light not detected',
                0x0007: 'Strobe return light detected',
                0x0009: 'Flash fired, compulsory flash mode',
                0x000d: 'Flash fired, compulsory flash mode, return light not detected',
                0x000f: 'Flash fired, compulsory flash mode, return light detected',
                0x0010: 'Flash did not fire, compulsory flash mode',
                0x0018: 'Flash did not fire, auto mode',
                0x0019: 'Flash fired, auto mode',
                0x001d: 'Flash fired, auto mode, return light not detected',
                0x001f: 'Flash fired, auto mode, return light detected',
                0x0020: 'No flash function',
                0x0041: 'Flash fired, red-eye reduction mode',
                0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
                0x0047: 'Flash fired, red-eye reduction mode, return light detected',
                0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
                0x004d: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
                0x004f: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
                0x0059: 'Flash fired, auto mode, red-eye reduction mode',
                0x005d: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
                0x005f: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
            },
            SensingMethod: {
                1: 'Not defined',
                2: 'One-chip color area sensor',
                3: 'Two-chip color area sensor',
                4: 'Three-chip color area sensor',
                5: 'Color sequential area sensor',
                7: 'Trilinear sensor',
                8: 'Color sequential linear sensor'
            },
            SceneCaptureType: {
                0: 'Standard',
                1: 'Landscape',
                2: 'Portrait',
                3: 'Night scene'
            },
            SceneType: {
                1: 'Directly photographed'
            },
            CustomRendered: {
                0: 'Normal process',
                1: 'Custom process'
            },
            WhiteBalance: {
                0: 'Auto white balance',
                1: 'Manual white balance'
            },
            GainControl: {
                0: 'None',
                1: 'Low gain up',
                2: 'High gain up',
                3: 'Low gain down',
                4: 'High gain down'
            },
            Contrast: {
                0: 'Normal',
                1: 'Soft',
                2: 'Hard'
            },
            Saturation: {
                0: 'Normal',
                1: 'Low saturation',
                2: 'High saturation'
            },
            Sharpness: {
                0: 'Normal',
                1: 'Soft',
                2: 'Hard'
            },
            SubjectDistanceRange: {
                0: 'Unknown',
                1: 'Macro',
                2: 'Close view',
                3: 'Distant view'
            },
            FileSource: {
                3: 'DSC'
            },
            Components: {
                0: '',
                1: 'Y',
                2: 'Cb',
                3: 'Cr',
                4: 'R',
                5: 'G',
                6: 'B'
            }
        };
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEvent(element, event, handler) {
        if (element.addEventListener) {
            element.addEventListener(event, handler, false);
        }
        else {
            // Hello, IE!
            if (element.attachEvent) {
                element.attachEvent('on' + event, handler);
            }
        }
    }
    /**
     * @param {?} img
     * @return {?}
     */
    imageHasData(img) {
        return !!img.exifdata;
    }
    /**
     * @param {?} base64
     * @return {?}
     */
    base64ToArrayBuffer(base64) {
        base64 = base64.replace(/^data:([^;]+);base64,/gim, '');
        /** @type {?} */
        const binary = atob(base64);
        /** @type {?} */
        const len = binary.length;
        /** @type {?} */
        const buffer = new ArrayBuffer(len);
        /** @type {?} */
        const view = new Uint8Array(buffer);
        for (let i = 0; i < len; i++) {
            view[i] = binary.charCodeAt(i);
        }
        return buffer;
    }
    /**
     * @param {?} url
     * @param {?} callback
     * @return {?}
     */
    objectURLToBlob(url, callback) {
        /** @type {?} */
        const http = new XMLHttpRequest();
        http.open('GET', url, true);
        http.responseType = 'blob';
        http.onload = (/**
         * @return {?}
         */
        () => {
            if (http.status === 200 || http.status === 0) {
                callback(http.response);
            }
        });
        http.send();
    }
    /**
     * @param {?} img
     * @param {?} callback
     * @return {?}
     */
    getImageData(img, callback) {
        /** @type {?} */
        const handleBinaryFile = (/**
         * @param {?} binFile
         * @return {?}
         */
        (binFile) => {
            /** @type {?} */
            const data = this.findEXIFinJPEG(binFile);
            /** @type {?} */
            const iptcdata = this.findIPTCinJPEG(binFile);
            ((/** @type {?} */ (img))).exifdata = data || {};
            ((/** @type {?} */ (img))).iptcdata = iptcdata || {};
            if (callback) {
                callback.call(img);
            }
        });
        if ('src' in img && ((/** @type {?} */ (img))).src) {
            if (/^data:/i.test(((/** @type {?} */ (img))).src)) {
                // Data URI
                /** @type {?} */
                const arrayBuffer = this.base64ToArrayBuffer(((/** @type {?} */ (img))).src);
                handleBinaryFile(arrayBuffer);
            }
            else {
                if (/^blob:/i.test(((/** @type {?} */ (img))).src)) {
                    // Object URL
                    /** @type {?} */
                    const fileReader = new FileReader();
                    fileReader.onload = (/**
                     * @param {?} e
                     * @return {?}
                     */
                    (e) => {
                        handleBinaryFile(e.target.result);
                    });
                    this.objectURLToBlob(((/** @type {?} */ (img))).src, (/**
                     * @param {?} blob
                     * @return {?}
                     */
                    (blob) => {
                        fileReader.readAsArrayBuffer(blob);
                    }));
                }
                else {
                    /** @type {?} */
                    const http = new XMLHttpRequest();
                    http.onload = (/**
                     * @return {?}
                     */
                    () => {
                        if (http.status === 200 || http.status === 0) {
                            handleBinaryFile(http.response);
                        }
                        else {
                            throw new Error('Could not load image');
                        }
                    });
                    http.open('GET', ((/** @type {?} */ (img))).src, true);
                    http.responseType = 'arraybuffer';
                    http.send(null);
                }
            }
        }
        else {
            if (FileReader && (img instanceof Blob || img instanceof File)) {
                /** @type {?} */
                const fileReader = new FileReader();
                fileReader.onload = (/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    this.log('Got file of length ' + e.target.result.byteLength);
                    handleBinaryFile(e.target.result);
                });
                fileReader.readAsArrayBuffer(img);
            }
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    findEXIFinJPEG(file) {
        /** @type {?} */
        const dataView = new DataView(file);
        this.log('Got file of length ' + file.byteLength);
        if (dataView.getUint8(0) !== 0xff || dataView.getUint8(1) !== 0xd8) {
            this.log('Not a valid JPEG');
            return false; // not a valid jpeg
        }
        /** @type {?} */
        let offset = 2;
        /** @type {?} */
        const length = file.byteLength;
        /** @type {?} */
        let marker;
        while (offset < length) {
            if (dataView.getUint8(offset) !== 0xff) {
                this.log('Not a valid marker at offset ' +
                    offset +
                    ', found: ' +
                    dataView.getUint8(offset));
                return false; // not a valid marker, something is wrong
            }
            marker = dataView.getUint8(offset + 1);
            this.log(marker);
            // we could implement handling for other markers here,
            // but we're only looking for 0xFFE1 for EXIF data
            if (marker === 225) {
                this.log('Found 0xFFE1 marker');
                return this.readEXIFData(dataView, offset + 4); // , dataView.getUint16(offset + 2) - 2);
                // offset += 2 + file.getShortAt(offset+2, true);
            }
            else {
                offset += 2 + dataView.getUint16(offset + 2);
            }
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    findIPTCinJPEG(file) {
        /** @type {?} */
        const dataView = new DataView(file);
        this.log('Got file of length ' + file.byteLength);
        if (dataView.getUint8(0) !== 0xff || dataView.getUint8(1) !== 0xd8) {
            this.log('Not a valid JPEG');
            return false; // not a valid jpeg
        }
        /** @type {?} */
        let offset = 2;
        /** @type {?} */
        const length = file.byteLength;
        // tslint:disable-next-line:variable-name
        /** @type {?} */
        const isFieldSegmentStart = (/**
         * @param {?} _dataView
         * @param {?} _offset
         * @return {?}
         */
        (_dataView, _offset) => {
            return (_dataView.getUint8(_offset) === 0x38 &&
                _dataView.getUint8(_offset + 1) === 0x42 &&
                _dataView.getUint8(_offset + 2) === 0x49 &&
                _dataView.getUint8(_offset + 3) === 0x4d &&
                _dataView.getUint8(_offset + 4) === 0x04 &&
                _dataView.getUint8(_offset + 5) === 0x04);
        });
        while (offset < length) {
            if (isFieldSegmentStart(dataView, offset)) {
                // Get the length of the name header (which is padded to an even number of bytes)
                /** @type {?} */
                let nameHeaderLength = dataView.getUint8(offset + 7);
                if (nameHeaderLength % 2 !== 0) {
                    nameHeaderLength += 1;
                }
                // Check for pre photoshop 6 format
                if (nameHeaderLength === 0) {
                    // Always 4
                    nameHeaderLength = 4;
                }
                /** @type {?} */
                const startOffset = offset + 8 + nameHeaderLength;
                /** @type {?} */
                const sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);
                return this.readIPTCData(file, startOffset, sectionLength);
            }
            // Not the marker, continue searching
            offset++;
        }
    }
    /**
     * @param {?} file
     * @param {?} startOffset
     * @param {?} sectionLength
     * @return {?}
     */
    readIPTCData(file, startOffset, sectionLength) {
        /** @type {?} */
        const dataView = new DataView(file);
        /** @type {?} */
        const data = {};
        /** @type {?} */
        let fieldValue;
        /** @type {?} */
        let fieldName;
        /** @type {?} */
        let dataSize;
        /** @type {?} */
        let segmentType;
        /** @type {?} */
        let segmentStartPos = startOffset;
        while (segmentStartPos < startOffset + sectionLength) {
            if (dataView.getUint8(segmentStartPos) === 0x1c &&
                dataView.getUint8(segmentStartPos + 1) === 0x02) {
                segmentType = dataView.getUint8(segmentStartPos + 2);
                if (segmentType in this.IptcFieldMap) {
                    dataSize = dataView.getInt16(segmentStartPos + 3);
                    fieldName = this.IptcFieldMap[segmentType];
                    fieldValue = this.getStringFromDB(dataView, segmentStartPos + 5, dataSize);
                    // Check if we already stored a value with this name
                    if (data.hasOwnProperty(fieldName)) {
                        // Value already stored with this name, create multivalue field
                        if (data[fieldName] instanceof Array) {
                            data[fieldName].push(fieldValue);
                        }
                        else {
                            data[fieldName] = [data[fieldName], fieldValue];
                        }
                    }
                    else {
                        data[fieldName] = fieldValue;
                    }
                }
            }
            segmentStartPos++;
        }
        return data;
    }
    /**
     * @param {?} file
     * @param {?} tiffStart
     * @param {?} dirStart
     * @param {?} strings
     * @param {?} bigEnd
     * @return {?}
     */
    readTags(file, tiffStart, dirStart, strings, bigEnd) {
        /** @type {?} */
        const entries = file.getUint16(dirStart, !bigEnd);
        /** @type {?} */
        const tags = {};
        /** @type {?} */
        let entryOffset;
        /** @type {?} */
        let tag;
        for (let i = 0; i < entries; i++) {
            entryOffset = dirStart + i * 12 + 2;
            tag = strings[file.getUint16(entryOffset, !bigEnd)];
            if (!tag) {
                this.log('Unknown tag: ' + file.getUint16(entryOffset, !bigEnd));
            }
            tags[tag] = this.readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
        }
        return tags;
    }
    /**
     * @param {?} file
     * @param {?} entryOffset
     * @param {?} tiffStart
     * @param {?} dirStart
     * @param {?} bigEnd
     * @return {?}
     */
    readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
        /** @type {?} */
        const type = file.getUint16(entryOffset + 2, !bigEnd);
        /** @type {?} */
        const numValues = file.getUint32(entryOffset + 4, !bigEnd);
        /** @type {?} */
        const valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart;
        /** @type {?} */
        let offset;
        /** @type {?} */
        let vals;
        /** @type {?} */
        let val;
        /** @type {?} */
        let n;
        /** @type {?} */
        let numerator;
        /** @type {?} */
        let denominator;
        switch (type) {
            case 1: // byte, 8-bit unsigned int
            case 7: // undefined, 8-bit byte, value depending on field
                if (numValues === 1) {
                    return file.getUint8(entryOffset + 8, !bigEnd);
                }
                else {
                    offset = numValues > 4 ? valueOffset : entryOffset + 8;
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getUint8(offset + n);
                    }
                    return vals;
                }
            case 2: // ascii, 8-bit byte
                offset = numValues > 4 ? valueOffset : entryOffset + 8;
                return this.getStringFromDB(file, offset, numValues - 1);
            case 3: // short, 16 bit int
                if (numValues === 1) {
                    return file.getUint16(entryOffset + 8, !bigEnd);
                }
                else {
                    offset = numValues > 2 ? valueOffset : entryOffset + 8;
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getUint16(offset + 2 * n, !bigEnd);
                    }
                    return vals;
                }
            case 4: // long, 32 bit int
                if (numValues === 1) {
                    return file.getUint32(entryOffset + 8, !bigEnd);
                }
                else {
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);
                    }
                    return vals;
                }
            case 5: // rational = two long values, first is numerator, second is denominator
                if (numValues === 1) {
                    numerator = file.getUint32(valueOffset, !bigEnd);
                    denominator = file.getUint32(valueOffset + 4, !bigEnd);
                    val = new Fraction(numerator / denominator);
                    val.numerator = numerator;
                    val.denominator = denominator;
                    return val;
                }
                else {
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);
                        denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);
                        vals[n] = new Fraction(numerator / denominator);
                        vals[n].numerator = numerator;
                        vals[n].denominator = denominator;
                    }
                    return vals;
                }
            case 9: // slong, 32 bit signed int
                if (numValues === 1) {
                    return file.getInt32(entryOffset + 8, !bigEnd);
                }
                else {
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);
                    }
                    return vals;
                }
            case 10: // signed rational, two slongs, first is numerator, second is denominator
                if (numValues === 1) {
                    return (file.getInt32(valueOffset, !bigEnd) /
                        file.getInt32(valueOffset + 4, !bigEnd));
                }
                else {
                    vals = [];
                    for (n = 0; n < numValues; n++) {
                        vals[n] =
                            file.getInt32(valueOffset + 8 * n, !bigEnd) /
                                file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);
                    }
                    return vals;
                }
            default:
                break;
        }
    }
    /**
     * @param {?} buffer
     * @param {?} start
     * @param {?} length
     * @return {?}
     */
    getStringFromDB(buffer, start, length) {
        /** @type {?} */
        let outstr = '';
        for (let n = start; n < start + length; n++) {
            outstr += String.fromCharCode(buffer.getUint8(n));
        }
        return outstr;
    }
    /**
     * @param {?} file
     * @param {?} start
     * @return {?}
     */
    readEXIFData(file, start) {
        if (this.getStringFromDB(file, start, 4) !== 'Exif') {
            this.log('Not valid EXIF data! ' + this.getStringFromDB(file, start, 4));
            return false;
        }
        /** @type {?} */
        let bigEnd;
        /** @type {?} */
        let tags;
        /** @type {?} */
        let tag;
        /** @type {?} */
        let exifData;
        /** @type {?} */
        let gpsData;
        /** @type {?} */
        const tiffOffset = start + 6;
        // test for TIFF validity and endianness
        if (file.getUint16(tiffOffset) === 0x4949) {
            bigEnd = false;
        }
        else {
            if (file.getUint16(tiffOffset) === 0x4d4d) {
                bigEnd = true;
            }
            else {
                this.log('Not valid TIFF data! (no 0x4949 or 0x4D4D)');
                return false;
            }
        }
        if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {
            this.log('Not valid TIFF data! (no 0x002A)');
            return false;
        }
        /** @type {?} */
        const firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);
        if (firstIFDOffset < 0x00000008) {
            this.log('Not valid TIFF data! (First offset less than 8)', file.getUint32(tiffOffset + 4, !bigEnd));
            return false;
        }
        tags = this.readTags(file, tiffOffset, tiffOffset + firstIFDOffset, this.TiffTags, bigEnd);
        if (tags.ExifIFDPointer) {
            exifData = this.readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, this.Tags, bigEnd);
            for (tag in exifData) {
                if ({}.hasOwnProperty.call(exifData, tag)) {
                    switch (tag) {
                        case 'LightSource':
                        case 'Flash':
                        case 'MeteringMode':
                        case 'ExposureProgram':
                        case 'SensingMethod':
                        case 'SceneCaptureType':
                        case 'SceneType':
                        case 'CustomRendered':
                        case 'WhiteBalance':
                        case 'GainControl':
                        case 'Contrast':
                        case 'Saturation':
                        case 'Sharpness':
                        case 'SubjectDistanceRange':
                        case 'FileSource':
                            exifData[tag] = this.StringValues[tag][exifData[tag]];
                            break;
                        case 'ExifVersion':
                        case 'FlashpixVersion':
                            exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);
                            break;
                        case 'ComponentsConfiguration':
                            /** @type {?} */
                            const compopents = 'Components';
                            exifData[tag] =
                                this.StringValues[compopents][exifData[tag][0]] +
                                    this.StringValues[compopents][exifData[tag][1]] +
                                    this.StringValues[compopents][exifData[tag][2]] +
                                    this.StringValues[compopents][exifData[tag][3]];
                            break;
                        default:
                            break;
                    }
                    tags[tag] = exifData[tag];
                }
            }
        }
        if (tags.GPSInfoIFDPointer) {
            gpsData = this.readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, this.GPSTags, bigEnd);
            for (tag in gpsData) {
                if ({}.hasOwnProperty.call(gpsData, tag)) {
                    switch (tag) {
                        case 'GPSVersionID':
                            gpsData[tag] =
                                gpsData[tag][0] +
                                    '.' +
                                    gpsData[tag][1] +
                                    '.' +
                                    gpsData[tag][2] +
                                    '.' +
                                    gpsData[tag][3];
                            break;
                        default:
                            break;
                    }
                    tags[tag] = gpsData[tag];
                }
            }
        }
        return tags;
    }
    //   get rid of this silly issue
    /**
     * @private
     * @param {?} img
     * @return {?}
     */
    checkImageType(img) {
        return img instanceof Image || img instanceof HTMLImageElement;
    }
    /**
     * @param {?} img
     * @param {?} callback
     * @return {?}
     */
    getData(img, callback) {
        if (this.checkImageType(img) && !img.complete) {
            return false;
        }
        if (!this.imageHasData((/** @type {?} */ (img)))) {
            this.getImageData((/** @type {?} */ (img)), callback);
        }
        else {
            if (callback) {
                callback.call(img);
            }
        }
        return true;
    }
    /**
     * @param {?} img
     * @param {?} tag
     * @return {?}
     */
    getTag(img, tag) {
        if (!this.imageHasData(img)) {
            return;
        }
        return img.exifdata[tag];
    }
    /**
     * @param {?} img
     * @return {?}
     */
    getAllTags(img) {
        if (!this.imageHasData(img)) {
            return {};
        }
        /** @type {?} */
        let a;
        /** @type {?} */
        const data = img.exifdata;
        /** @type {?} */
        const tags = {};
        for (a in data) {
            if (data.hasOwnProperty(a)) {
                tags[a] = data[a];
            }
        }
        return tags;
    }
    /**
     * @param {?} img
     * @return {?}
     */
    pretty(img) {
        if (!this.imageHasData(img)) {
            return '';
        }
        /** @type {?} */
        let a;
        /** @type {?} */
        const data = img.exifdata;
        /** @type {?} */
        let strPretty = '';
        for (a in data) {
            if (data.hasOwnProperty(a)) {
                if (typeof data[a] === 'object') {
                    if (data[a] instanceof Number) {
                        strPretty += `${a} : ${data[a]} [${data[a].numerator}/${data[a].denominator}]\r\n`;
                    }
                    else {
                        strPretty += `${a} : [${data[a].length} values]\r\n`;
                    }
                }
                else {
                    strPretty += `${a} : ${data[a]}\r\n`;
                }
            }
        }
        return strPretty;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    readFromBinaryFile(file) {
        return this.findEXIFinJPEG(file);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    log(...args) {
        if (this.debug) {
            console.log(args);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Point {
    /**
     * @param {?=} x
     * @param {?=} y
     */
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    /**
     * @return {?}
     */
    get next() {
        return this.myNext;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    set next(p) {
        this.myNext = p;
    }
    /**
     * @return {?}
     */
    get prev() {
        return this.myPrev;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    set prev(p) {
        this.myPrev = p;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PointPool {
    /**
     * @param {?=} initialSize
     */
    constructor(initialSize = 1) {
        /** @type {?} */
        let prev = (this.firstAvailable = new Point());
        for (let i = 1; i < initialSize; i++) {
            /** @type {?} */
            const p = new Point();
            prev.next = p;
            prev = p;
        }
    }
    /**
     * @return {?}
     */
    get instance() {
        return this;
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    borrow(x, y) {
        if (this.firstAvailable == null) {
            throw new Error('Pool exhausted');
        }
        this.borrowed++;
        /** @type {?} */
        const p = this.firstAvailable;
        this.firstAvailable = p.next;
        p.x = x;
        p.y = y;
        return p;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    returnPoint(p) {
        this.borrowed--;
        p.x = 0;
        p.y = 0;
        p.next = this.firstAvailable;
        this.firstAvailable = p;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Bounds {
    /**
     * @param {?=} x
     * @param {?=} y
     * @param {?=} width
     * @param {?=} height
     */
    constructor(x, y, width, height) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (width === void 0) {
            width = 0;
        }
        if (height === void 0) {
            height = 0;
        }
        this.left = x;
        this.right = x + width;
        this.top = y;
        this.bottom = y + height;
    }
    /**
     * @return {?}
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * @return {?}
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * @return {?}
     */
    getCentre() {
        /** @type {?} */
        const w = this.width;
        /** @type {?} */
        const h = this.height;
        return new PointPool().instance.borrow(this.left + w / 2, this.top + h / 2);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Handle {
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} radius
     * @param {?} settings
     */
    constructor(x, y, radius, settings) {
        this.cropperSettings = new CropperSettings();
        this.over = false;
        this.drag = false;
        this._position = new Point(x, y);
        this.offset = new Point(0, 0);
        this.radius = radius;
        this.cropperSettings = settings;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setDrag(value) {
        this.drag = value;
        this.setOver(value);
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    draw(ctx) {
        // this should't be empty
    }
    /**
     * @param {?} over
     * @return {?}
     */
    setOver(over) {
        this.over = over;
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    touchInBounds(x, y) {
        return (x > this.position.x - this.radius + this.offset.x &&
            x < this.position.x + this.radius + this.offset.x &&
            y > this.position.y - this.radius + this.offset.y &&
            y < this.position.y + this.radius + this.offset.y);
    }
    /**
     * @return {?}
     */
    get position() {
        return this._position;
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    setPosition(x, y) {
        this._position.x = x;
        this._position.y = y;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CornerMarker extends Handle {
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} radius
     * @param {?} cropperSettings
     */
    constructor(x, y, radius, cropperSettings) {
        super(x, y, radius, cropperSettings);
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    drawCornerBorder(ctx) {
        /** @type {?} */
        let sideLength = 10;
        if (this.over || this.drag) {
            sideLength = 12;
        }
        /** @type {?} */
        let hDirection = this.cropperSettings.markerSizeMultiplier;
        /** @type {?} */
        let vDirection = this.cropperSettings.markerSizeMultiplier;
        if (this.horizontalNeighbour.position.x < this.position.x) {
            hDirection = -this.cropperSettings.markerSizeMultiplier;
        }
        if (this.verticalNeighbour.position.y < this.position.y) {
            vDirection = -this.cropperSettings.markerSizeMultiplier;
        }
        ctx.beginPath();
        if (this.cropperSettings.cropperDrawSettings.lineDash) {
            ctx.setLineDash([1, 3]);
        }
        ctx.lineJoin = 'miter';
        ctx.moveTo(this.position.x + this.offset.x, this.position.y + this.offset.y);
        ctx.lineTo(this.position.x + this.offset.x + sideLength * hDirection, this.position.y + this.offset.y);
        ctx.lineTo(this.position.x + this.offset.x + sideLength * hDirection, this.position.y + this.offset.y + sideLength * vDirection);
        ctx.lineTo(this.position.x + this.offset.x, this.position.y + this.offset.y + sideLength * vDirection);
        ctx.lineTo(this.position.x + this.offset.x, this.position.y + this.offset.y);
        ctx.closePath();
        ctx.lineWidth = this.cropperSettings.cropperDrawSettings.strokeWidth;
        ctx.strokeStyle =
            this.cropperSettings.cropperDrawSettings.strokeColor ||
                'rgba(255,255,255,.7)';
        ctx.stroke();
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    drawCornerFill(ctx) {
        /** @type {?} */
        let sideLength = 10;
        if (this.over || this.drag) {
            sideLength = 12;
        }
        /** @type {?} */
        let hDirection = this.cropperSettings.markerSizeMultiplier;
        /** @type {?} */
        let vDirection = this.cropperSettings.markerSizeMultiplier;
        if (this.horizontalNeighbour.position.x < this.position.x) {
            hDirection = -this.cropperSettings.markerSizeMultiplier;
        }
        if (this.verticalNeighbour.position.y < this.position.y) {
            vDirection = -this.cropperSettings.markerSizeMultiplier;
        }
        if (this.cropperSettings.rounded) {
            /** @type {?} */
            const width = this.position.x - this.horizontalNeighbour.position.x;
            /** @type {?} */
            const height = this.position.y - this.verticalNeighbour.position.y;
            /** @type {?} */
            const offX = Math.round(Math.sin(Math.PI / 2) * Math.abs(width / 2)) / 4;
            /** @type {?} */
            const offY = Math.round(Math.sin(Math.PI / 2) * Math.abs(height / 2)) / 4;
            this.offset.x = hDirection > 0 ? offX : -offX;
            this.offset.y = vDirection > 0 ? offY : -offY;
        }
        else {
            this.offset.x = 0;
            this.offset.y = 0;
        }
        ctx.beginPath();
        if (this.cropperSettings.cropperDrawSettings.lineDash) {
            ctx.setLineDash([1, 3]);
        }
        ctx.moveTo(this.position.x + this.offset.x, this.position.y + this.offset.y);
        ctx.lineTo(this.position.x + this.offset.x + sideLength * hDirection, this.position.y + this.offset.y);
        ctx.lineTo(this.position.x + this.offset.x + sideLength * hDirection, this.position.y + this.offset.y + sideLength * vDirection);
        ctx.lineTo(this.position.x + this.offset.x, this.position.y + this.offset.y + sideLength * vDirection);
        ctx.lineTo(this.position.x + this.offset.x, this.position.y + this.offset.y);
        ctx.closePath();
        ctx.fillStyle =
            this.cropperSettings.cropperDrawSettings.fillColor ||
                'rgba(255,255,255,.7)';
        ctx.fill();
    }
    /**
     * @param {?} x
     * @return {?}
     */
    moveX(x) {
        this.setPosition(x, this.position.y);
    }
    /**
     * @param {?} y
     * @return {?}
     */
    moveY(y) {
        this.setPosition(this.position.x, y);
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    move(x, y) {
        this.setPosition(x, y);
        this.verticalNeighbour.moveX(x);
        this.horizontalNeighbour.moveY(y);
    }
    /**
     * @param {?} neighbour
     * @return {?}
     */
    addHorizontalNeighbour(neighbour) {
        this.horizontalNeighbour = neighbour;
    }
    /**
     * @param {?} neighbour
     * @return {?}
     */
    addVerticalNeighbour(neighbour) {
        this.verticalNeighbour = neighbour;
    }
    /**
     * @return {?}
     */
    getHorizontalNeighbour() {
        return this.horizontalNeighbour;
    }
    /**
     * @return {?}
     */
    getVerticalNeighbour() {
        return this.verticalNeighbour;
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    draw(ctx) {
        this.drawCornerFill(ctx);
        this.drawCornerBorder(ctx);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CropTouch {
    /**
     * @param {?=} x
     * @param {?=} y
     * @param {?=} id
     */
    constructor(x = 0, y = 0, id = 0) {
        this.id = id;
        this.x = x;
        this.y = y;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragMarker extends Handle {
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} radius
     * @param {?} cropperSettings
     */
    constructor(x, y, radius, cropperSettings) {
        super(x, y, radius, cropperSettings);
        this.iconPoints = [];
        this.scaledIconPoints = [];
        this.getDragIconPoints(this.iconPoints, 1);
        this.getDragIconPoints(this.scaledIconPoints, 1.2);
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    draw(ctx) {
        if (this.over || this.drag) {
            this.drawIcon(ctx, this.scaledIconPoints);
        }
        else {
            this.drawIcon(ctx, this.iconPoints);
        }
    }
    /**
     * @param {?} arr
     * @param {?} scale
     * @return {?}
     */
    getDragIconPoints(arr, scale) {
        /** @type {?} */
        const maxLength = 17 * scale;
        /** @type {?} */
        const arrowWidth = 14 * scale;
        /** @type {?} */
        const arrowLength = 8 * scale;
        /** @type {?} */
        const connectorThroat = 4 * scale;
        arr.push(new PointPool().instance.borrow(-connectorThroat / 2, maxLength - arrowLength));
        arr.push(new PointPool().instance.borrow(-arrowWidth / 2, maxLength - arrowLength));
        arr.push(new PointPool().instance.borrow(0, maxLength));
        arr.push(new PointPool().instance.borrow(arrowWidth / 2, maxLength - arrowLength));
        arr.push(new PointPool().instance.borrow(connectorThroat / 2, maxLength - arrowLength));
        arr.push(new PointPool().instance.borrow(connectorThroat / 2, connectorThroat / 2));
        arr.push(new PointPool().instance.borrow(maxLength - arrowLength, connectorThroat / 2));
        arr.push(new PointPool().instance.borrow(maxLength - arrowLength, arrowWidth / 2));
        arr.push(new PointPool().instance.borrow(maxLength, 0));
        arr.push(new PointPool().instance.borrow(maxLength - arrowLength, -arrowWidth / 2));
        arr.push(new PointPool().instance.borrow(maxLength - arrowLength, -connectorThroat / 2));
        arr.push(new PointPool().instance.borrow(connectorThroat / 2, -connectorThroat / 2));
        arr.push(new PointPool().instance.borrow(connectorThroat / 2, -maxLength + arrowLength));
        arr.push(new PointPool().instance.borrow(arrowWidth / 2, -maxLength + arrowLength));
        arr.push(new PointPool().instance.borrow(0, -maxLength));
        arr.push(new PointPool().instance.borrow(-arrowWidth / 2, -maxLength + arrowLength));
        arr.push(new PointPool().instance.borrow(-connectorThroat / 2, -maxLength + arrowLength));
        arr.push(new PointPool().instance.borrow(-connectorThroat / 2, -connectorThroat / 2));
        arr.push(new PointPool().instance.borrow(-maxLength + arrowLength, -connectorThroat / 2));
        arr.push(new PointPool().instance.borrow(-maxLength + arrowLength, -arrowWidth / 2));
        arr.push(new PointPool().instance.borrow(-maxLength, 0));
        arr.push(new PointPool().instance.borrow(-maxLength + arrowLength, arrowWidth / 2));
        arr.push(new PointPool().instance.borrow(-maxLength + arrowLength, connectorThroat / 2));
        arr.push(new PointPool().instance.borrow(-connectorThroat / 2, connectorThroat / 2));
    }
    /**
     * @param {?} ctx
     * @param {?} points
     * @return {?}
     */
    drawIcon(ctx, points) {
        if (this.cropperSettings.showCenterMarker) {
            ctx.beginPath();
            ctx.moveTo(points[0].x + this.position.x, points[0].y + this.position.y);
            for (const p of points) {
                ctx.lineTo(p.x + this.position.x, p.y + this.position.y);
            }
            ctx.closePath();
            ctx.fillStyle = this.cropperSettings.cropperDrawSettings.dragIconFillColor;
            ctx.fill();
            ctx.lineWidth = this.cropperSettings.cropperDrawSettings.dragIconStrokeWidth;
            ctx.strokeStyle = this.cropperSettings.cropperDrawSettings.dragIconStrokeColor;
            ctx.stroke();
        }
    }
    /**
     * @param {?} bounds
     * @return {?}
     */
    recalculatePosition(bounds) {
        /** @type {?} */
        const c = bounds.getCentre();
        this.setPosition(c.x, c.y);
        new PointPool().instance.returnPoint(c);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageCropperModel {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageCropperDataShare {
    constructor() {
        this.share = {};
    }
    /**
     * @param {?} canvas
     * @return {?}
     */
    setPressed(canvas) {
        this.pressed = canvas;
    }
    /**
     * @param {?} canvas
     * @return {?}
     */
    setReleased(canvas) {
        if (canvas === this.pressed) ;
    }
    /**
     * @param {?} canvas
     * @return {?}
     */
    setOver(canvas) {
        this.over = canvas;
    }
    /**
     * @param {?} canvas
     * @param {?} style
     * @return {?}
     */
    setStyle(canvas, style) {
        if (this.pressed !== undefined) {
            if (this.pressed === canvas) ;
        }
        else {
            if (canvas === this.over) ;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageCropper extends ImageCropperModel {
    /**
     * @param {?} cropperSettings
     */
    constructor(cropperSettings) {
        super();
        this.imageCropperDataShare = new ImageCropperDataShare();
        /** @type {?} */
        const x = 0;
        /** @type {?} */
        const y = 0;
        /** @type {?} */
        const width = cropperSettings.width;
        /** @type {?} */
        const height = cropperSettings.height;
        /** @type {?} */
        const keepAspect = cropperSettings.keepAspect;
        /** @type {?} */
        const touchRadius = cropperSettings.touchRadius;
        /** @type {?} */
        const centerTouchRadius = cropperSettings.centerTouchRadius;
        /** @type {?} */
        const minWidth = cropperSettings.minWidth;
        /** @type {?} */
        const minHeight = cropperSettings.minHeight;
        /** @type {?} */
        const croppedWidth = cropperSettings.croppedWidth;
        /** @type {?} */
        const croppedHeight = cropperSettings.croppedHeight;
        this.cropperSettings = cropperSettings;
        this.crop = this;
        this.x = x;
        this.y = y;
        this.canvasHeight = cropperSettings.canvasHeight;
        this.canvasWidth = cropperSettings.canvasWidth;
        this.width = width;
        if (width === void 0) {
            this.width = 100;
        }
        this.height = height;
        if (height === void 0) {
            this.height = 50;
        }
        this.keepAspect = keepAspect;
        if (keepAspect === void 0) {
            this.keepAspect = true;
        }
        this.touchRadius = touchRadius;
        if (touchRadius === void 0) {
            this.touchRadius = 20;
        }
        this.minWidth = minWidth;
        this.minHeight = minHeight;
        this.aspectRatio = 0;
        this.currentDragTouches = [];
        this.isMouseDown = false;
        this.ratioW = 1;
        this.ratioH = 1;
        this.fileType = cropperSettings.fileType;
        this.imageSet = false;
        this.pointPool = new PointPool(200);
        this.tl = new CornerMarker(x, y, touchRadius, this.cropperSettings);
        this.tr = new CornerMarker(x + width, y, touchRadius, this.cropperSettings);
        this.bl = new CornerMarker(x, y + height, touchRadius, this.cropperSettings);
        this.br = new CornerMarker(x + width, y + height, touchRadius, this.cropperSettings);
        this.tl.addHorizontalNeighbour(this.tr);
        this.tl.addVerticalNeighbour(this.bl);
        this.tr.addHorizontalNeighbour(this.tl);
        this.tr.addVerticalNeighbour(this.br);
        this.bl.addHorizontalNeighbour(this.br);
        this.bl.addVerticalNeighbour(this.tl);
        this.br.addHorizontalNeighbour(this.bl);
        this.br.addVerticalNeighbour(this.tr);
        this.markers = [this.tl, this.tr, this.bl, this.br];
        this.center = new DragMarker(x + width / 2, y + height / 2, centerTouchRadius, this.cropperSettings);
        this.aspectRatio = height / width;
        this.croppedImage = new Image();
        this.currentlyInteracting = false;
        this.cropWidth = croppedWidth;
        this.cropHeight = croppedHeight;
    }
    /**
     * @private
     * @param {?} x
     * @return {?}
     */
    sign(x) {
        if (+x === x) {
            return x === 0 ? x : x > 0 ? 1 : -1;
        }
        return NaN;
    }
    /**
     * @private
     * @param {?} canvas
     * @param {?} evt
     * @return {?}
     */
    getMousePos(canvas, evt) {
        /** @type {?} */
        const rect = canvas.getBoundingClientRect();
        return new PointPool().instance.borrow(evt.clientX - rect.left, evt.clientY - rect.top);
    }
    /**
     * @private
     * @param {?} canvas
     * @param {?} touch
     * @return {?}
     */
    getTouchPos(canvas, touch) {
        /** @type {?} */
        const rect = canvas.getBoundingClientRect();
        return new PointPool().instance.borrow(touch.clientX - rect.left, touch.clientY - rect.top);
    }
    /**
     * @private
     * @param {?} img
     * @return {?}
     */
    detectVerticalSquash(img) {
        /** @type {?} */
        const ih = img.height;
        /** @type {?} */
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = ih;
        /** @type {?} */
        const ctx = (/** @type {?} */ (canvas.getContext('2d')));
        ctx.drawImage(img, 0, 0);
        /** @type {?} */
        const imageData = ctx.getImageData(0, 0, 1, ih);
        if (imageData) {
            /** @type {?} */
            const data = imageData.data;
            // search image edge pixel position in case it is squashed vertically.
            /** @type {?} */
            let sy = 0;
            /** @type {?} */
            let ey = ih;
            /** @type {?} */
            let py = ih;
            while (py > sy) {
                /** @type {?} */
                const alpha = data[(py - 1) * 4 + 3];
                if (alpha === 0) {
                    ey = py;
                }
                else {
                    sy = py;
                }
                // tslint:disable-next-line:no-bitwise
                py = (ey + sy) >> 1;
            }
            /** @type {?} */
            const ratio = py / ih;
            return ratio === 0 ? 1 : ratio;
        }
        else {
            return 1;
        }
    }
    /**
     * @private
     * @param {?} dataUri
     * @return {?}
     */
    getDataUriMimeType(dataUri) {
        // Get a substring because the regex does not perform well on very large strings.
        // Cater for optional charset. Length 50 shoould be enough.
        /** @type {?} */
        const dataUriSubstring = dataUri.substring(0, 50);
        /** @type {?} */
        let mimeType = 'image/png';
        // data-uri scheme
        // data:[<media type>][;charset=<character set>][;base64],<data>
        /** @type {?} */
        const regEx = RegExp(/^(data:)([\w\/\+]+);(charset=[\w-]+|base64).*,(.*)/gi);
        /** @type {?} */
        const matches = regEx.exec(dataUriSubstring);
        if (matches && matches[2]) {
            mimeType = matches[2];
            if (mimeType === 'image/jpg') {
                mimeType = 'image/jpeg';
            }
        }
        return mimeType;
    }
    /**
     * @param {?} canvas
     * @return {?}
     */
    prepare(canvas) {
        this.buffer = document.createElement('canvas');
        this.cropCanvas = document.createElement('canvas');
        // todo get more reliable parent width value.
        /** @type {?} */
        const responsiveWidth = canvas.parentElement
            ? canvas.parentElement.clientWidth
            : 0;
        if (responsiveWidth > 0 && this.cropperSettings.dynamicSizing) {
            this.cropCanvas.width = responsiveWidth;
            this.buffer.width = responsiveWidth;
            canvas.width = responsiveWidth;
        }
        else {
            this.cropCanvas.width = this.cropWidth;
            this.buffer.width = canvas.width;
        }
        this.cropCanvas.height = this.cropHeight;
        this.buffer.height = canvas.height;
        this.canvas = canvas;
        this.ctx = (/** @type {?} */ (this.canvas.getContext('2d')));
        this.draw(this.ctx);
    }
    /**
     * @param {?} cropperSettings
     * @return {?}
     */
    updateSettings(cropperSettings) {
        this.cropperSettings = cropperSettings;
    }
    /**
     * @param {?} width
     * @param {?} height
     * @param {?=} setImage
     * @return {?}
     */
    resizeCanvas(width, height, setImage = false) {
        this.canvas.width = this.cropCanvas.width = this.width = this.canvasWidth = this.buffer.width = width;
        this.canvas.height = this.cropCanvas.height = this.height = this.canvasHeight = this.buffer.height = height;
        if (setImage) {
            this.setImage(this.srcImage);
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.setImage(undefined);
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    draw(ctx) {
        /** @type {?} */
        const bounds = this.getBounds();
        if (this.srcImage) {
            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
            /** @type {?} */
            const sourceAspect = this.srcImage.height / this.srcImage.width;
            /** @type {?} */
            const canvasAspect = this.canvasHeight / this.canvasWidth;
            /** @type {?} */
            let w = this.canvasWidth;
            /** @type {?} */
            let h = this.canvasHeight;
            if (canvasAspect > sourceAspect) {
                w = this.canvasWidth;
                h = this.canvasWidth * sourceAspect;
            }
            else {
                h = this.canvasHeight;
                w = this.canvasHeight / sourceAspect;
            }
            this.ratioW = w / this.srcImage.width;
            this.ratioH = h / this.srcImage.height;
            if (canvasAspect < sourceAspect) {
                this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, this.buffer.width / 2 - w / 2, 0, w, h);
            }
            else {
                this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, 0, this.buffer.height / 2 - h / 2, w, h);
            }
            ((/** @type {?} */ (this.buffer.getContext('2d')))).drawImage(this.canvas, 0, 0, this.canvasWidth, this.canvasHeight);
            ctx.lineWidth = this.cropperSettings.cropperDrawSettings.strokeWidth;
            ctx.strokeStyle = this.cropperSettings.cropperDrawSettings.strokeColor;
            ctx.fillStyle = this.cropperSettings.cropperDrawSettings.backgroundFillColor;
            if (!this.cropperSettings.rounded) {
                ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                ctx.drawImage(this.buffer, bounds.left, bounds.top, Math.max(bounds.width, 1), Math.max(bounds.height, 1), bounds.left, bounds.top, bounds.width, bounds.height);
                ctx.strokeRect(bounds.left, bounds.top, bounds.width, bounds.height);
            }
            else {
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                ctx.save();
                ctx.beginPath();
                ctx.arc(bounds.left + bounds.width / 2, bounds.top + bounds.height / 2, bounds.width / 2, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.clip();
                if (canvasAspect < sourceAspect) {
                    this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, this.buffer.width / 2 - w / 2, 0, w, h);
                }
                else {
                    this.drawImageIOSFix(ctx, this.srcImage, 0, 0, this.srcImage.width, this.srcImage.height, 0, this.buffer.height / 2 - h / 2, w, h);
                }
                ctx.restore();
            }
            /** @type {?} */
            let marker;
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < this.markers.length; i++) {
                marker = this.markers[i];
                marker.draw(ctx);
            }
            this.center.draw(ctx);
        }
        else {
            ctx.fillStyle = 'rgba(192,192,192,1)';
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
    }
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} marker
     * @return {?}
     */
    dragCenter(x, y, marker) {
        /** @type {?} */
        const bounds = this.getBounds();
        /** @type {?} */
        const left = x - bounds.width / 2;
        /** @type {?} */
        const right = x + bounds.width / 2;
        /** @type {?} */
        const top = y - bounds.height / 2;
        /** @type {?} */
        const bottom = y + bounds.height / 2;
        if (right >= this.maxXClamp) {
            x = this.maxXClamp - bounds.width / 2;
        }
        if (left <= this.minXClamp) {
            x = bounds.width / 2 + this.minXClamp;
        }
        if (top < this.minYClamp) {
            y = bounds.height / 2 + this.minYClamp;
        }
        if (bottom >= this.maxYClamp) {
            y = this.maxYClamp - bounds.height / 2;
        }
        this.tl.moveX(x - bounds.width / 2);
        this.tl.moveY(y - bounds.height / 2);
        this.tr.moveX(x + bounds.width / 2);
        this.tr.moveY(y - bounds.height / 2);
        this.bl.moveX(x - bounds.width / 2);
        this.bl.moveY(y + bounds.height / 2);
        this.br.moveX(x + bounds.width / 2);
        this.br.moveY(y + bounds.height / 2);
        marker.setPosition(x, y);
    }
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} marker
     * @return {?}
     */
    enforceMinSize(x, y, marker) {
        /** @type {?} */
        const xLength = x - marker.getHorizontalNeighbour().position.x;
        /** @type {?} */
        const yLength = y - marker.getVerticalNeighbour().position.y;
        /** @type {?} */
        const xOver = this.minWidth - Math.abs(xLength);
        /** @type {?} */
        const yOver = this.minHeight - Math.abs(yLength);
        if (xLength === 0 || yLength === 0) {
            x = marker.position.x;
            y = marker.position.y;
            return new PointPool().instance.borrow(x, y);
        }
        if (this.keepAspect) {
            if (xOver > 0 && yOver / this.aspectRatio > 0) {
                if (xOver > yOver / this.aspectRatio) {
                    if (xLength < 0) {
                        x -= xOver;
                        if (yLength < 0) {
                            y -= xOver * this.aspectRatio;
                        }
                        else {
                            y += xOver * this.aspectRatio;
                        }
                    }
                    else {
                        x += xOver;
                        if (yLength < 0) {
                            y -= xOver * this.aspectRatio;
                        }
                        else {
                            y += xOver * this.aspectRatio;
                        }
                    }
                }
                else {
                    if (yLength < 0) {
                        y -= yOver;
                        if (xLength < 0) {
                            x -= yOver / this.aspectRatio;
                        }
                        else {
                            x += yOver / this.aspectRatio;
                        }
                    }
                    else {
                        y += yOver;
                        if (xLength < 0) {
                            x -= yOver / this.aspectRatio;
                        }
                        else {
                            x += yOver / this.aspectRatio;
                        }
                    }
                }
            }
            else {
                if (xOver > 0) {
                    if (xLength < 0) {
                        x -= xOver;
                        if (yLength < 0) {
                            y -= xOver * this.aspectRatio;
                        }
                        else {
                            y += xOver * this.aspectRatio;
                        }
                    }
                    else {
                        x += xOver;
                        if (yLength < 0) {
                            y -= xOver * this.aspectRatio;
                        }
                        else {
                            y += xOver * this.aspectRatio;
                        }
                    }
                }
                else {
                    if (yOver > 0) {
                        if (yLength < 0) {
                            y -= yOver;
                            if (xLength < 0) {
                                x -= yOver / this.aspectRatio;
                            }
                            else {
                                x += yOver / this.aspectRatio;
                            }
                        }
                        else {
                            y += yOver;
                            if (xLength < 0) {
                                x -= yOver / this.aspectRatio;
                            }
                            else {
                                x += yOver / this.aspectRatio;
                            }
                        }
                    }
                }
            }
        }
        else {
            if (xOver > 0) {
                if (xLength < 0) {
                    x -= xOver;
                }
                else {
                    x += xOver;
                }
            }
            if (yOver > 0) {
                if (yLength < 0) {
                    y -= yOver;
                }
                else {
                    y += yOver;
                }
            }
        }
        if (x < this.minXClamp ||
            x > this.maxXClamp ||
            y < this.minYClamp ||
            y > this.maxYClamp) {
            x = marker.position.x;
            y = marker.position.y;
        }
        return new PointPool().instance.borrow(x, y);
    }
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} marker
     * @return {?}
     */
    dragCorner(x, y, marker) {
        /** @type {?} */
        let iX = 0;
        /** @type {?} */
        let iY = 0;
        /** @type {?} */
        let ax = 0;
        /** @type {?} */
        let ay = 0;
        /** @type {?} */
        let newHeight = 0;
        /** @type {?} */
        let newWidth = 0;
        /** @type {?} */
        let newY = 0;
        /** @type {?} */
        let newX = 0;
        /** @type {?} */
        let anchorMarker;
        /** @type {?} */
        let fold = 0;
        if (this.keepAspect) {
            anchorMarker = marker.getHorizontalNeighbour().getVerticalNeighbour();
            ax = anchorMarker.position.x;
            ay = anchorMarker.position.y;
            if (x <= anchorMarker.position.x) {
                if (y <= anchorMarker.position.y) {
                    iX = ax - 100 / this.aspectRatio;
                    iY = ay - (100 / this.aspectRatio) * this.aspectRatio;
                    fold = this.getSide(new PointPool().instance.borrow(iX, iY), anchorMarker.position, new PointPool().instance.borrow(x, y));
                    if (fold > 0) {
                        newHeight = Math.abs(anchorMarker.position.y - y);
                        newWidth = newHeight / this.aspectRatio;
                        newY = anchorMarker.position.y - newHeight;
                        newX = anchorMarker.position.x - newWidth;
                        /** @type {?} */
                        const min = this.enforceMinSize(newX, newY, marker);
                        marker.move(min.x, min.y);
                        new PointPool().instance.returnPoint(min);
                    }
                    else {
                        if (fold < 0) {
                            newWidth = Math.abs(anchorMarker.position.x - x);
                            newHeight = newWidth * this.aspectRatio;
                            newY = anchorMarker.position.y - newHeight;
                            newX = anchorMarker.position.x - newWidth;
                            /** @type {?} */
                            const min = this.enforceMinSize(newX, newY, marker);
                            marker.move(min.x, min.y);
                            new PointPool().instance.returnPoint(min);
                        }
                    }
                }
                else {
                    iX = ax - 100 / this.aspectRatio;
                    iY = ay + (100 / this.aspectRatio) * this.aspectRatio;
                    fold = this.getSide(new PointPool().instance.borrow(iX, iY), anchorMarker.position, new PointPool().instance.borrow(x, y));
                    if (fold > 0) {
                        newWidth = Math.abs(anchorMarker.position.x - x);
                        newHeight = newWidth * this.aspectRatio;
                        newY = anchorMarker.position.y + newHeight;
                        newX = anchorMarker.position.x - newWidth;
                        /** @type {?} */
                        const min = this.enforceMinSize(newX, newY, marker);
                        marker.move(min.x, min.y);
                        new PointPool().instance.returnPoint(min);
                    }
                    else {
                        if (fold < 0) {
                            newHeight = Math.abs(anchorMarker.position.y - y);
                            newWidth = newHeight / this.aspectRatio;
                            newY = anchorMarker.position.y + newHeight;
                            newX = anchorMarker.position.x - newWidth;
                            /** @type {?} */
                            const min = this.enforceMinSize(newX, newY, marker);
                            marker.move(min.x, min.y);
                            new PointPool().instance.returnPoint(min);
                        }
                    }
                }
            }
            else {
                if (y <= anchorMarker.position.y) {
                    iX = ax + 100 / this.aspectRatio;
                    iY = ay - (100 / this.aspectRatio) * this.aspectRatio;
                    fold = this.getSide(new PointPool().instance.borrow(iX, iY), anchorMarker.position, new PointPool().instance.borrow(x, y));
                    if (fold < 0) {
                        newHeight = Math.abs(anchorMarker.position.y - y);
                        newWidth = newHeight / this.aspectRatio;
                        newY = anchorMarker.position.y - newHeight;
                        newX = anchorMarker.position.x + newWidth;
                        /** @type {?} */
                        const min = this.enforceMinSize(newX, newY, marker);
                        marker.move(min.x, min.y);
                        new PointPool().instance.returnPoint(min);
                    }
                    else {
                        if (fold > 0) {
                            newWidth = Math.abs(anchorMarker.position.x - x);
                            newHeight = newWidth * this.aspectRatio;
                            newY = anchorMarker.position.y - newHeight;
                            newX = anchorMarker.position.x + newWidth;
                            /** @type {?} */
                            const min = this.enforceMinSize(newX, newY, marker);
                            marker.move(min.x, min.y);
                            new PointPool().instance.returnPoint(min);
                        }
                    }
                }
                else {
                    iX = ax + 100 / this.aspectRatio;
                    iY = ay + (100 / this.aspectRatio) * this.aspectRatio;
                    fold = this.getSide(new PointPool().instance.borrow(iX, iY), anchorMarker.position, new PointPool().instance.borrow(x, y));
                    if (fold < 0) {
                        newWidth = Math.abs(anchorMarker.position.x - x);
                        newHeight = newWidth * this.aspectRatio;
                        newY = anchorMarker.position.y + newHeight;
                        newX = anchorMarker.position.x + newWidth;
                        /** @type {?} */
                        const min = this.enforceMinSize(newX, newY, marker);
                        marker.move(min.x, min.y);
                        new PointPool().instance.returnPoint(min);
                    }
                    else {
                        if (fold > 0) {
                            newHeight = Math.abs(anchorMarker.position.y - y);
                            newWidth = newHeight / this.aspectRatio;
                            newY = anchorMarker.position.y + newHeight;
                            newX = anchorMarker.position.x + newWidth;
                            /** @type {?} */
                            const min = this.enforceMinSize(newX, newY, marker);
                            marker.move(min.x, min.y);
                            new PointPool().instance.returnPoint(min);
                        }
                    }
                }
            }
        }
        else {
            /** @type {?} */
            const min = this.enforceMinSize(x, y, marker);
            marker.move(min.x, min.y);
            new PointPool().instance.returnPoint(min);
        }
        this.center.recalculatePosition(this.getBounds());
    }
    /**
     * @param {?} a
     * @param {?} b
     * @param {?} c
     * @return {?}
     */
    getSide(a, b, c) {
        /** @type {?} */
        const n = this.sign((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x));
        // TODO move the return of the pools to outside of this function
        new PointPool().instance.returnPoint(a);
        new PointPool().instance.returnPoint(c);
        return n;
    }
    /**
     * @param {?} newCropTouch
     * @return {?}
     */
    handleRelease(newCropTouch) {
        if (newCropTouch == null) {
            return;
        }
        /** @type {?} */
        let index = 0;
        for (let k = 0; k < this.currentDragTouches.length; k++) {
            if (newCropTouch.id === this.currentDragTouches[k].id) {
                this.currentDragTouches[k].dragHandle.setDrag(false);
                index = k;
            }
        }
        this.currentDragTouches.splice(index, 1);
        this.draw(this.ctx);
    }
    /**
     * @param {?} newCropTouch
     * @return {?}
     */
    handleMove(newCropTouch) {
        /** @type {?} */
        let matched = false;
        // tslint:disable-next-line:prefer-for-of
        for (let k = 0; k < this.currentDragTouches.length; k++) {
            if (newCropTouch.id === this.currentDragTouches[k].id &&
                this.currentDragTouches[k].dragHandle != null) {
                /** @type {?} */
                const dragTouch = this.currentDragTouches[k];
                /** @type {?} */
                const clampedPositions = this.clampPosition(newCropTouch.x - dragTouch.dragHandle.offset.x, newCropTouch.y - dragTouch.dragHandle.offset.y);
                newCropTouch.x = clampedPositions.x;
                newCropTouch.y = clampedPositions.y;
                new PointPool().instance.returnPoint(clampedPositions);
                if (dragTouch.dragHandle instanceof CornerMarker) {
                    this.dragCorner(newCropTouch.x, newCropTouch.y, (/** @type {?} */ (dragTouch.dragHandle)));
                }
                else {
                    this.dragCenter(newCropTouch.x, newCropTouch.y, (/** @type {?} */ (dragTouch.dragHandle)));
                }
                this.currentlyInteracting = true;
                matched = true;
                this.imageCropperDataShare.setPressed(this.canvas);
                break;
            }
        }
        if (!matched) {
            for (const marker of this.markers) {
                if (marker.touchInBounds(newCropTouch.x, newCropTouch.y)) {
                    newCropTouch.dragHandle = marker;
                    this.currentDragTouches.push(newCropTouch);
                    marker.setDrag(true);
                    newCropTouch.dragHandle.offset.x =
                        newCropTouch.x - newCropTouch.dragHandle.position.x;
                    newCropTouch.dragHandle.offset.y =
                        newCropTouch.y - newCropTouch.dragHandle.position.y;
                    this.dragCorner(newCropTouch.x - newCropTouch.dragHandle.offset.x, newCropTouch.y - newCropTouch.dragHandle.offset.y, (/** @type {?} */ (newCropTouch.dragHandle)));
                    break;
                }
            }
            if (newCropTouch.dragHandle === null ||
                typeof newCropTouch.dragHandle === 'undefined') {
                if (this.center.touchInBounds(newCropTouch.x, newCropTouch.y)) {
                    newCropTouch.dragHandle = this.center;
                    this.currentDragTouches.push(newCropTouch);
                    newCropTouch.dragHandle.setDrag(true);
                    newCropTouch.dragHandle.offset.x =
                        newCropTouch.x - newCropTouch.dragHandle.position.x;
                    newCropTouch.dragHandle.offset.y =
                        newCropTouch.y - newCropTouch.dragHandle.position.y;
                    this.dragCenter(newCropTouch.x - newCropTouch.dragHandle.offset.x, newCropTouch.y - newCropTouch.dragHandle.offset.y, (/** @type {?} */ (newCropTouch.dragHandle)));
                }
            }
        }
    }
    /**
     * @return {?}
     */
    updateClampBounds() {
        /** @type {?} */
        const sourceAspect = this.srcImage.height / this.srcImage.width;
        /** @type {?} */
        const canvasAspect = this.canvas.height / this.canvas.width;
        /** @type {?} */
        let w = this.canvas.width;
        /** @type {?} */
        let h = this.canvas.height;
        if (canvasAspect > sourceAspect) {
            w = this.canvas.width;
            h = this.canvas.width * sourceAspect;
        }
        else {
            h = this.canvas.height;
            w = this.canvas.height / sourceAspect;
        }
        this.minXClamp = this.canvas.width / 2 - w / 2;
        this.minYClamp = this.canvas.height / 2 - h / 2;
        this.maxXClamp = this.canvas.width / 2 + w / 2;
        this.maxYClamp = this.canvas.height / 2 + h / 2;
    }
    /**
     * @return {?}
     */
    getCropBounds() {
        /** @type {?} */
        const bounds = this.getBounds();
        bounds.top = Math.round((bounds.top - this.minYClamp) / this.ratioH);
        bounds.bottom = Math.round((bounds.bottom - this.minYClamp) / this.ratioH);
        bounds.left = Math.round((bounds.left - this.minXClamp) / this.ratioW);
        bounds.right = Math.round((bounds.right - this.minXClamp) / this.ratioW);
        return bounds;
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    clampPosition(x, y) {
        if (x < this.minXClamp) {
            x = this.minXClamp;
        }
        if (x > this.maxXClamp) {
            x = this.maxXClamp;
        }
        if (y < this.minYClamp) {
            y = this.minYClamp;
        }
        if (y > this.maxYClamp) {
            y = this.maxYClamp;
        }
        return new PointPool().instance.borrow(x, y);
    }
    /**
     * @return {?}
     */
    isImageSet() {
        return this.imageSet;
    }
    /**
     * @param {?} img
     * @return {?}
     */
    setImage(img) {
        this.srcImage = img;
        if (!img) {
            this.imageSet = false;
            this.draw(this.ctx);
        }
        else {
            this.imageSet = true;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            /** @type {?} */
            const bufferContext = (/** @type {?} */ (this.buffer.getContext('2d')));
            bufferContext.clearRect(0, 0, this.buffer.width, this.buffer.height);
            if (!this.cropperSettings.fileType) {
                this.fileType = this.getDataUriMimeType(img.src);
            }
            if (this.cropperSettings.minWithRelativeToResolution) {
                this.minWidth =
                    (this.canvas.width * this.cropperSettings.minWidth) /
                        this.srcImage.width;
                this.minHeight =
                    (this.canvas.height * this.cropperSettings.minHeight) /
                        this.srcImage.height;
            }
            this.updateClampBounds();
            this.canvasWidth = this.canvas.width;
            this.canvasHeight = this.canvas.height;
            /** @type {?} */
            const cropPosition = this.getCropPositionFromMarkers();
            this.setCropPosition(cropPosition);
        }
    }
    /**
     * @param {?} cropBounds
     * @return {?}
     */
    updateCropPosition(cropBounds) {
        /** @type {?} */
        const cropPosition = this.getCropPositionFromBounds(cropBounds);
        this.setCropPosition(cropPosition);
    }
    /**
     * @private
     * @param {?} cropPosition
     * @return {?}
     */
    setCropPosition(cropPosition) {
        this.tl.setPosition(cropPosition[0].x, cropPosition[0].y);
        this.tr.setPosition(cropPosition[1].x, cropPosition[1].y);
        this.bl.setPosition(cropPosition[2].x, cropPosition[2].y);
        this.br.setPosition(cropPosition[3].x, cropPosition[3].y);
        this.center.setPosition(cropPosition[4].x, cropPosition[4].y);
        for (const position of cropPosition) {
            new PointPool().instance.returnPoint(position);
        }
        this.vertSquashRatio = this.detectVerticalSquash(this.srcImage);
        this.draw(this.ctx);
        this.croppedImage = this.getCroppedImageHelper(false, this.cropWidth, this.cropHeight);
    }
    /**
     * @private
     * @return {?}
     */
    getCropPositionFromMarkers() {
        /** @type {?} */
        const w = this.canvas.width;
        /** @type {?} */
        const h = this.canvas.height;
        /** @type {?} */
        let tlPos;
        /** @type {?} */
        let trPos;
        /** @type {?} */
        let blPos;
        /** @type {?} */
        let brPos;
        /** @type {?} */
        let center;
        /** @type {?} */
        const sourceAspect = this.srcImage.height / this.srcImage.width;
        /** @type {?} */
        const cropBounds = this.getBounds();
        /** @type {?} */
        const cropAspect = cropBounds.height / cropBounds.width;
        /** @type {?} */
        const cX = this.canvas.width / 2;
        /** @type {?} */
        const cY = this.canvas.height / 2;
        if (cropAspect > sourceAspect) {
            /** @type {?} */
            const imageH = Math.min(w * sourceAspect, h);
            /** @type {?} */
            const cropW = imageH / cropAspect;
            tlPos = new PointPool().instance.borrow(cX - cropW / 2, cY + imageH / 2);
            trPos = new PointPool().instance.borrow(cX + cropW / 2, cY + imageH / 2);
            blPos = new PointPool().instance.borrow(cX - cropW / 2, cY - imageH / 2);
            brPos = new PointPool().instance.borrow(cX + cropW / 2, cY - imageH / 2);
        }
        else {
            /** @type {?} */
            const imageW = Math.min(h / sourceAspect, w);
            /** @type {?} */
            const cropH = imageW * cropAspect;
            tlPos = new PointPool().instance.borrow(cX - imageW / 2, cY + cropH / 2);
            trPos = new PointPool().instance.borrow(cX + imageW / 2, cY + cropH / 2);
            blPos = new PointPool().instance.borrow(cX - imageW / 2, cY - cropH / 2);
            brPos = new PointPool().instance.borrow(cX + imageW / 2, cY - cropH / 2);
        }
        center = new PointPool().instance.borrow(cX, cY);
        /** @type {?} */
        const positions = [tlPos, trPos, blPos, brPos, center];
        return positions;
    }
    /**
     * @private
     * @param {?} cropPosition
     * @return {?}
     */
    getCropPositionFromBounds(cropPosition) {
        /** @type {?} */
        let marginTop = 0;
        /** @type {?} */
        let marginLeft = 0;
        /** @type {?} */
        const canvasAspect = this.canvasHeight / this.canvasWidth;
        /** @type {?} */
        const sourceAspect = this.srcImage.height / this.srcImage.width;
        if (canvasAspect > sourceAspect) {
            marginTop =
                this.buffer.height / 2 - (this.canvasWidth * sourceAspect) / 2;
        }
        else {
            marginLeft = this.buffer.width / 2 - this.canvasHeight / sourceAspect / 2;
        }
        /** @type {?} */
        const ratioW = (this.canvasWidth - marginLeft * 2) / this.srcImage.width;
        /** @type {?} */
        const ratioH = (this.canvasHeight - marginTop * 2) / this.srcImage.height;
        /** @type {?} */
        let actualH = cropPosition.height * ratioH;
        /** @type {?} */
        let actualW = cropPosition.width * ratioW;
        /** @type {?} */
        const actualX = cropPosition.left * ratioW + marginLeft;
        /** @type {?} */
        const actualY = cropPosition.top * ratioH + marginTop;
        if (this.keepAspect) {
            /** @type {?} */
            const scaledW = actualH / this.aspectRatio;
            /** @type {?} */
            const scaledH = actualW * this.aspectRatio;
            if (this.getCropBounds().height === cropPosition.height) {
                // only width changed
                actualH = scaledH;
            }
            else if (this.getCropBounds().width === cropPosition.width) {
                // only height changed
                actualW = scaledW;
            }
            else {
                // height and width changed
                if (Math.abs(scaledH - actualH) < Math.abs(scaledW - actualW)) {
                    actualW = scaledW;
                }
                else {
                    actualH = scaledH;
                }
            }
        }
        /** @type {?} */
        const tlPos = new PointPool().instance.borrow(actualX, actualY + actualH);
        /** @type {?} */
        const trPos = new PointPool().instance.borrow(actualX + actualW, actualY + actualH);
        /** @type {?} */
        const blPos = new PointPool().instance.borrow(actualX, actualY);
        /** @type {?} */
        const brPos = new PointPool().instance.borrow(actualX + actualW, actualY);
        /** @type {?} */
        const center = new PointPool().instance.borrow(actualX + actualW / 2, actualY + actualH / 2);
        /** @type {?} */
        const positions = [tlPos, trPos, blPos, brPos, center];
        return positions;
    }
    /**
     * @param {?=} preserveSize
     * @param {?=} fillWidth
     * @param {?=} fillHeight
     * @return {?}
     */
    getCroppedImageHelper(preserveSize, fillWidth, fillHeight) {
        if (this.cropperSettings.cropOnResize) {
            return this.getCroppedImage(preserveSize, fillWidth, fillHeight);
        }
        return this.croppedImage
            ? this.croppedImage
            : document.createElement('img');
    }
    // todo: Unused parameters?
    /**
     * @param {?=} preserveSize
     * @param {?=} fillWidth
     * @param {?=} fillHeight
     * @return {?}
     */
    getCroppedImage(preserveSize, fillWidth, fillHeight) {
        /** @type {?} */
        const bounds = this.getBounds();
        if (!this.srcImage) {
            return document.createElement('img');
        }
        else {
            /** @type {?} */
            const sourceAspect = this.srcImage.height / this.srcImage.width;
            /** @type {?} */
            const canvasAspect = this.canvas.height / this.canvas.width;
            /** @type {?} */
            let w = this.canvas.width;
            /** @type {?} */
            let h = this.canvas.height;
            if (canvasAspect > sourceAspect) {
                w = this.canvas.width;
                h = this.canvas.width * sourceAspect;
            }
            else {
                if (canvasAspect < sourceAspect) {
                    h = this.canvas.height;
                    w = this.canvas.height / sourceAspect;
                }
                else {
                    h = this.canvas.height;
                    w = this.canvas.width;
                }
            }
            this.ratioW = w / this.srcImage.width;
            this.ratioH = h / this.srcImage.height;
            /** @type {?} */
            const offsetH = (this.buffer.height - h) / 2 / this.ratioH;
            /** @type {?} */
            const offsetW = (this.buffer.width - w) / 2 / this.ratioW;
            /** @type {?} */
            const ctx = (/** @type {?} */ (this.cropCanvas.getContext('2d')));
            if (this.cropperSettings.preserveSize || preserveSize) {
                /** @type {?} */
                const width = Math.round(bounds.right / this.ratioW - bounds.left / this.ratioW);
                /** @type {?} */
                const height = Math.round(bounds.bottom / this.ratioH - bounds.top / this.ratioH);
                this.cropCanvas.width = width;
                this.cropCanvas.height = height;
                this.cropperSettings.croppedWidth = this.cropCanvas.width;
                this.cropperSettings.croppedHeight = this.cropCanvas.height;
            }
            else {
                this.cropCanvas.width = this.cropWidth;
                this.cropCanvas.height = this.cropHeight;
            }
            ctx.clearRect(0, 0, this.cropCanvas.width, this.cropCanvas.height);
            this.drawImageIOSFix(ctx, this.srcImage, Math.max(Math.round(bounds.left / this.ratioW - offsetW), 0), Math.max(Math.round(bounds.top / this.ratioH - offsetH), 0), Math.max(Math.round(bounds.width / this.ratioW), 1), Math.max(Math.round(bounds.height / this.ratioH), 1), 0, 0, this.cropCanvas.width, this.cropCanvas.height);
            if (this.cropperSettings.resampleFn) {
                this.cropperSettings.resampleFn(this.cropCanvas);
            }
            this.croppedImage.width = this.cropCanvas.width;
            this.croppedImage.height = this.cropCanvas.height;
            this.croppedImage.src = this.cropCanvas.toDataURL(this.fileType, this.cropperSettings.compressRatio);
            return this.croppedImage;
        }
    }
    /**
     * @return {?}
     */
    getBounds() {
        /** @type {?} */
        let minX = Number.MAX_VALUE;
        /** @type {?} */
        let minY = Number.MAX_VALUE;
        /** @type {?} */
        let maxX = -Number.MAX_VALUE;
        /** @type {?} */
        let maxY = -Number.MAX_VALUE;
        for (const marker of this.markers) {
            if (marker.position.x < minX) {
                minX = marker.position.x;
            }
            if (marker.position.x > maxX) {
                maxX = marker.position.x;
            }
            if (marker.position.y < minY) {
                minY = marker.position.y;
            }
            if (marker.position.y > maxY) {
                maxY = marker.position.y;
            }
        }
        /** @type {?} */
        const bounds = new Bounds();
        bounds.left = minX;
        bounds.right = maxX;
        bounds.top = minY;
        bounds.bottom = maxY;
        return bounds;
    }
    /**
     * @param {?} bounds
     * @return {?}
     */
    setBounds(bounds) {
        // const topLeft: CornerMarker;
        // const topRight: CornerMarker;
        // const bottomLeft: CornerMarker;
        // const bottomRight: CornerMarker;
        // const topLeft: CornerMarker;
        // const topRight: CornerMarker;
        // const bottomLeft: CornerMarker;
        // const bottomRight: CornerMarker;
        /** @type {?} */
        const currentBounds = this.getBounds();
        for (const marker of this.markers) {
            if (marker.position.x === currentBounds.left) {
                if (marker.position.y === currentBounds.top) {
                    marker.setPosition(bounds.left, bounds.top);
                }
                else {
                    marker.setPosition(bounds.left, bounds.bottom);
                }
            }
            else {
                if (marker.position.y === currentBounds.top) {
                    marker.setPosition(bounds.right, bounds.top);
                }
                else {
                    marker.setPosition(bounds.right, bounds.bottom);
                }
            }
        }
        this.center.recalculatePosition(bounds);
        this.center.draw(this.ctx);
        this.draw(this.ctx); // we need to redraw all canvas if we have changed bounds
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        if (this.crop.isImageSet()) {
            if (event.touches.length === 1) {
                if (this.isMouseDown) {
                    event.preventDefault();
                    // tslint:disable-next-line:prefer-for-of
                    for (let i = 0; i < event.touches.length; i++) {
                        /** @type {?} */
                        const touch = event.touches[i];
                        /** @type {?} */
                        const touchPosition = this.getTouchPos(this.canvas, touch);
                        /** @type {?} */
                        const cropTouch = new CropTouch(touchPosition.x, touchPosition.y, touch.identifier);
                        new PointPool().instance.returnPoint(touchPosition);
                        this.move(cropTouch);
                    }
                }
            }
            else {
                if (event.touches.length === 2) {
                    event.preventDefault();
                    /** @type {?} */
                    const distance = (event.touches[0].clientX - event.touches[1].clientX) *
                        (event.touches[0].clientX - event.touches[1].clientX) +
                        (event.touches[0].clientY - event.touches[1].clientY) *
                            (event.touches[0].clientY - event.touches[1].clientY);
                    if (this.previousDistance && this.previousDistance !== distance) {
                        /** @type {?} */
                        const bounds = this.getBounds();
                        if (distance < this.previousDistance) {
                            bounds.top += 1;
                            bounds.left += 1;
                            bounds.right -= 1;
                            bounds.bottom -= 1;
                        }
                        if (distance > this.previousDistance) {
                            if (bounds.top !== this.minYClamp &&
                                bounds.bottom !== this.maxYClamp &&
                                bounds.left !== this.minXClamp &&
                                bounds.right !== this.maxXClamp) {
                                // none
                                bounds.top -= 1;
                                bounds.left -= 1;
                                bounds.right += 1;
                                bounds.bottom += 1;
                            }
                            else if (bounds.top !== this.minYClamp &&
                                bounds.bottom !== this.maxYClamp &&
                                bounds.left === this.minXClamp &&
                                bounds.right !== this.maxXClamp) {
                                // left
                                bounds.top -= 1;
                                bounds.right += 2;
                                bounds.bottom += 1;
                            }
                            else if (bounds.top !== this.minYClamp &&
                                bounds.bottom !== this.maxYClamp &&
                                bounds.left !== this.minXClamp &&
                                bounds.right === this.maxXClamp) {
                                // right
                                bounds.top -= 1;
                                bounds.left -= 2;
                                bounds.bottom += 1;
                            }
                            else if (bounds.top === this.minYClamp &&
                                bounds.bottom !== this.maxYClamp &&
                                bounds.left !== this.minXClamp &&
                                bounds.right !== this.maxXClamp) {
                                // top
                                bounds.left -= 1;
                                bounds.right += 1;
                                bounds.bottom += 2;
                            }
                            else if (bounds.top !== this.minYClamp &&
                                bounds.bottom === this.maxYClamp &&
                                bounds.left !== this.minXClamp &&
                                bounds.right !== this.maxXClamp) {
                                // bottom
                                bounds.top -= 2;
                                bounds.left -= 1;
                                bounds.right += 1;
                            }
                            else if (bounds.top === this.minYClamp &&
                                bounds.bottom !== this.maxYClamp &&
                                bounds.left === this.minXClamp &&
                                bounds.right !== this.maxXClamp) {
                                // top left
                                bounds.right += 2;
                                bounds.bottom += 2;
                            }
                            else if (bounds.top === this.minYClamp &&
                                bounds.bottom !== this.maxYClamp &&
                                bounds.left !== this.minXClamp &&
                                bounds.right === this.maxXClamp) {
                                // top right
                                bounds.left -= 2;
                                bounds.bottom += 2;
                            }
                            else if (bounds.top !== this.minYClamp &&
                                bounds.bottom === this.maxYClamp &&
                                bounds.left === this.minXClamp &&
                                bounds.right !== this.maxXClamp) {
                                // bottom left
                                bounds.top -= 2;
                                bounds.right += 2;
                            }
                            else if (bounds.top !== this.minYClamp &&
                                bounds.bottom === this.maxYClamp &&
                                bounds.left !== this.minXClamp &&
                                bounds.right === this.maxXClamp) {
                                // bottom right
                                bounds.top -= 2;
                                bounds.left -= 2;
                            }
                        }
                        if (bounds.top < this.minYClamp) {
                            bounds.top = this.minYClamp;
                        }
                        if (bounds.bottom > this.maxYClamp) {
                            bounds.bottom = this.maxYClamp;
                        }
                        if (bounds.left < this.minXClamp) {
                            bounds.left = this.minXClamp;
                        }
                        if (bounds.right > this.maxXClamp) {
                            bounds.right = this.maxXClamp;
                        }
                        this.setBounds(bounds);
                    }
                    this.previousDistance = distance;
                }
            }
            this.draw(this.ctx);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseMove(e) {
        if (this.crop.isImageSet() && this.isMouseDown) {
            /** @type {?} */
            const mousePosition = this.getMousePos(this.canvas, e);
            this.move(new CropTouch(mousePosition.x, mousePosition.y, 0));
            /** @type {?} */
            let dragTouch = this.getDragTouchForID(0);
            if (dragTouch) {
                dragTouch.x = mousePosition.x;
                dragTouch.y = mousePosition.y;
            }
            else {
                dragTouch = new CropTouch(mousePosition.x, mousePosition.y, 0);
            }
            new PointPool().instance.returnPoint(mousePosition);
            this.drawCursors(dragTouch);
            this.draw(this.ctx);
        }
    }
    /**
     * @param {?} cropTouch
     * @return {?}
     */
    move(cropTouch) {
        if (this.isMouseDown) {
            this.handleMove(cropTouch);
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getDragTouchForID(id) {
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < this.currentDragTouches.length; i++) {
            if (id === this.currentDragTouches[i].id) {
                return this.currentDragTouches[i];
            }
        }
        return undefined;
    }
    /**
     * @param {?} cropTouch
     * @return {?}
     */
    drawCursors(cropTouch) {
        /** @type {?} */
        let cursorDrawn = false;
        if (cropTouch != null) {
            if (cropTouch.dragHandle === this.center) {
                this.imageCropperDataShare.setStyle(this.canvas, 'move');
                cursorDrawn = true;
            }
            if (cropTouch.dragHandle !== null &&
                cropTouch.dragHandle instanceof CornerMarker) {
                this.drawCornerCursor(cropTouch.dragHandle, cropTouch.dragHandle.position.x, cropTouch.dragHandle.position.y);
                cursorDrawn = true;
            }
        }
        /** @type {?} */
        let didDraw = false;
        if (!cursorDrawn) {
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < this.markers.length; i++) {
                didDraw =
                    didDraw ||
                        this.drawCornerCursor(this.markers[i], cropTouch.x, cropTouch.y);
            }
            if (!didDraw) {
                this.imageCropperDataShare.setStyle(this.canvas, 'initial');
            }
        }
        if (!didDraw &&
            !cursorDrawn &&
            this.center.touchInBounds(cropTouch.x, cropTouch.y)) {
            this.center.setOver(true);
            this.imageCropperDataShare.setOver(this.canvas);
            this.imageCropperDataShare.setStyle(this.canvas, 'move');
        }
        else {
            this.center.setOver(false);
        }
    }
    /**
     * @param {?} marker
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    drawCornerCursor(marker, x, y) {
        if (marker.touchInBounds(x, y)) {
            marker.setOver(true);
            if (marker.getHorizontalNeighbour().position.x > marker.position.x) {
                if (marker.getVerticalNeighbour().position.y > marker.position.y) {
                    this.imageCropperDataShare.setOver(this.canvas);
                    this.imageCropperDataShare.setStyle(this.canvas, 'nwse-resize');
                }
                else {
                    this.imageCropperDataShare.setOver(this.canvas);
                    this.imageCropperDataShare.setStyle(this.canvas, 'nesw-resize');
                }
            }
            else {
                if (marker.getVerticalNeighbour().position.y > marker.position.y) {
                    this.imageCropperDataShare.setOver(this.canvas);
                    this.imageCropperDataShare.setStyle(this.canvas, 'nesw-resize');
                }
                else {
                    this.imageCropperDataShare.setOver(this.canvas);
                    this.imageCropperDataShare.setStyle(this.canvas, 'nwse-resize');
                }
            }
            return true;
        }
        marker.setOver(false);
        return false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        if (this.crop.isImageSet()) {
            /** @type {?} */
            const touch = event.touches[0];
            /** @type {?} */
            const touchPosition = this.getTouchPos(this.canvas, touch);
            /** @type {?} */
            const cropTouch = new CropTouch(touchPosition.x, touchPosition.y, touch.identifier);
            new PointPool().instance.returnPoint(touchPosition);
            this.isMouseDown = false;
            for (const marker of this.markers) {
                if (marker.touchInBounds(cropTouch.x, cropTouch.y)) {
                    this.isMouseDown = true;
                }
            }
            if (this.center.touchInBounds(cropTouch.x, cropTouch.y)) {
                this.isMouseDown = true;
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchEnd(event) {
        if (this.crop.isImageSet()) {
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < event.changedTouches.length; i++) {
                /** @type {?} */
                const touch = event.changedTouches[i];
                /** @type {?} */
                const dragTouch = this.getDragTouchForID(touch.identifier);
                if (dragTouch && dragTouch !== undefined) {
                    if (dragTouch.dragHandle instanceof CornerMarker ||
                        dragTouch.dragHandle instanceof DragMarker) {
                        dragTouch.dragHandle.setOver(false);
                    }
                    this.handleRelease(dragTouch);
                }
            }
            if (this.currentDragTouches.length === 0) {
                this.isMouseDown = false;
                this.currentlyInteracting = false;
            }
        }
    }
    // http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
    /**
     * @param {?} ctx
     * @param {?} img
     * @param {?} sx
     * @param {?} sy
     * @param {?} sw
     * @param {?} sh
     * @param {?} dx
     * @param {?} dy
     * @param {?} dw
     * @param {?} dh
     * @return {?}
     */
    drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
        // Works only if whole image is displayed:
        // ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
        // The following works correct also when only a part of the image is displayed:
        // ctx.drawImage(img, sx * this.vertSquashRatio, sy * this.vertSquashRatio, sw * this.vertSquashRatio, sh *
        // this.vertSquashRatio, dx, dy, dw, dh);
        ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        if (this.crop.isImageSet()) {
            this.isMouseDown = true;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        if (this.crop.isImageSet()) {
            this.imageCropperDataShare.setReleased(this.canvas);
            this.isMouseDown = false;
            this.handleRelease(new CropTouch(0, 0, 0));
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CropPosition {
    /**
     * @param {?=} x
     * @param {?=} y
     * @param {?=} w
     * @param {?=} h
     */
    constructor(x = 0, y = 0, w = 0, h = 0) {
        this.x = +x;
        this.y = +y;
        this.w = +w;
        this.h = +h;
    }
    /**
     * @return {?}
     */
    toBounds() {
        return new Bounds(this.x, this.y, this.w, this.h);
    }
    /**
     * @return {?}
     */
    isInitialized() {
        return this.x !== 0 && this.y !== 0 && this.w !== 0 && this.h !== 0;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageCropperComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.cropPositionChange = new EventEmitter();
        this.exif = new Exif();
        // tslint:disable-next-line:no-output-on-prefix
        this.onCrop = new EventEmitter();
        this.imageSet = new EventEmitter();
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const canvas = this.cropcanvas.nativeElement;
        if (!this.settings) {
            this.settings = new CropperSettings();
        }
        if (this.settings.cropperClass) {
            this.renderer.setAttribute(canvas, 'class', this.settings.cropperClass);
        }
        if (!this.settings.dynamicSizing) {
            this.renderer.setAttribute(canvas, 'width', this.settings.canvasWidth.toString());
            this.renderer.setAttribute(canvas, 'height', this.settings.canvasHeight.toString());
        }
        else {
            this.windowListener = this.resize.bind(this);
            window.addEventListener('resize', this.windowListener);
        }
        if (!this.cropper) {
            this.cropper = new ImageCropper(this.settings);
        }
        this.cropper.prepare(canvas);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.isCropPositionChanged(changes)) {
            this.cropper.updateCropPosition(this.cropPosition.toBounds());
            if (this.cropper.isImageSet()) {
                /** @type {?} */
                const bounds = this.cropper.getCropBounds();
                this.image.image = this.cropper.getCroppedImageHelper().src;
                this.onCrop.emit(bounds);
            }
            this.updateCropBounds();
        }
        if (changes.inputImage) {
            this.setImage(changes.inputImage.currentValue);
        }
        if (changes.settings && this.cropper) {
            this.cropper.updateSettings(this.settings);
            if (this.cropper.isImageSet()) {
                this.image.image = this.cropper.getCroppedImageHelper().src;
                this.onCrop.emit(this.cropper.getCropBounds());
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.settings.dynamicSizing && this.windowListener) {
            window.removeEventListener('resize', this.windowListener);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        this.cropper.onTouchMove(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        this.cropper.onTouchStart(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchEnd(event) {
        this.cropper.onTouchEnd(event);
        if (this.cropper.isImageSet()) {
            this.image.image = this.cropper.getCroppedImageHelper().src;
            this.onCrop.emit(this.cropper.getCropBounds());
            this.updateCropBounds();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        this.cropper.onMouseDown(event);
        // if (!this.cropper.isImageSet() && !this.settings.noFileInput) {
        //   // load img
        //   this.fileInput.nativeElement.click();
        // }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        if (this.cropper.isImageSet()) {
            this.cropper.onMouseUp(event);
            this.image.image = this.cropper.getCroppedImageHelper().src;
            this.onCrop.emit(this.cropper.getCropBounds());
            this.updateCropBounds();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        this.cropper.onMouseMove(event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    fileChangeListener($event) {
        if ($event.target.files.length === 0) {
            return;
        }
        /** @type {?} */
        const file = $event.target.files[0];
        if (this.settings.allowedFilesRegex.test(file.name)) {
            /** @type {?} */
            const image = new Image();
            /** @type {?} */
            const fileReader = new FileReader();
            fileReader.addEventListener('loadend', (/**
             * @param {?} loadEvent
             * @return {?}
             */
            (loadEvent) => {
                image.addEventListener('load', (/**
                 * @return {?}
                 */
                () => {
                    this.setImage(image);
                }));
                image.src = loadEvent.target.result;
            }));
            fileReader.readAsDataURL(file);
        }
    }
    /**
     * @private
     * @return {?}
     */
    resize() {
        /** @type {?} */
        const canvas = this.cropcanvas.nativeElement;
        this.settings.canvasWidth = canvas.offsetWidth;
        this.settings.canvasHeight = canvas.offsetHeight;
        this.cropper.resizeCanvas(canvas.offsetWidth, canvas.offsetHeight, true);
    }
    /**
     * @return {?}
     */
    reset() {
        this.cropper.reset();
        this.renderer.setAttribute(this.cropcanvas.nativeElement, 'class', this.settings.cropperClass);
        this.image.image = this.cropper.getCroppedImageHelper().src;
    }
    /**
     * @param {?} image
     * @param {?=} newBounds
     * @return {?}
     */
    setImage(image, newBounds = null) {
        this.imageSet.emit(true);
        this.renderer.setAttribute(this.cropcanvas.nativeElement, 'class', `${this.settings.cropperClass} ${this.settings.croppingClass}`);
        this.raf = window.requestAnimationFrame((/**
         * @return {?}
         */
        () => {
            if (this.raf) {
                window.cancelAnimationFrame(this.raf);
            }
            if (image.naturalHeight > 0 && image.naturalWidth > 0) {
                image.height = image.naturalHeight;
                image.width = image.naturalWidth;
                window.cancelAnimationFrame(this.raf);
                this.getOrientedImage(image, (/**
                 * @param {?} img
                 * @return {?}
                 */
                (img) => {
                    if (this.settings.dynamicSizing) {
                        /** @type {?} */
                        const canvas = this.cropcanvas.nativeElement;
                        this.settings.canvasWidth = canvas.offsetWidth;
                        this.settings.canvasHeight = canvas.offsetHeight;
                        this.cropper.resizeCanvas(canvas.offsetWidth, canvas.offsetHeight, false);
                    }
                    this.cropper.setImage(img);
                    if (this.cropPosition && this.cropPosition.isInitialized()) {
                        this.cropper.updateCropPosition(this.cropPosition.toBounds());
                    }
                    this.image.original = img;
                    /** @type {?} */
                    let bounds = this.cropper.getCropBounds();
                    this.image.image = this.cropper.getCroppedImageHelper().src;
                    if (!this.image) {
                        this.image = image;
                    }
                    if (newBounds != null) {
                        bounds = newBounds;
                        this.cropper.setBounds(bounds);
                        this.cropper.updateCropPosition(bounds);
                    }
                    this.onCrop.emit(bounds);
                }));
            }
        }));
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    isCropPositionChanged(changes) {
        if (this.cropper &&
            changes.cropPosition &&
            this.isCropPositionUpdateNeeded) {
            return true;
        }
        else {
            this.isCropPositionUpdateNeeded = true;
            return false;
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateCropBounds() {
        /** @type {?} */
        const cropBound = this.cropper.getCropBounds();
        this.cropPositionChange.emit(new CropPosition(cropBound.left, cropBound.top, cropBound.width, cropBound.height));
        this.isCropPositionUpdateNeeded = false;
    }
    /**
     * @private
     * @param {?} image
     * @param {?} callback
     * @return {?}
     */
    getOrientedImage(image, callback) {
        /** @type {?} */
        let img;
        this.exif.getData(image, (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const orientation = this.exif.getTag(image, 'Orientation');
            if ([3, 6, 8].indexOf(orientation) > -1) {
                /** @type {?} */
                const canvas = document.createElement('canvas');
                /** @type {?} */
                const ctx = (/** @type {?} */ (canvas.getContext('2d')));
                /** @type {?} */
                let cw = image.width;
                /** @type {?} */
                let ch = image.height;
                /** @type {?} */
                let cx = 0;
                /** @type {?} */
                let cy = 0;
                /** @type {?} */
                let deg = 0;
                switch (orientation) {
                    case 3:
                        cx = -image.width;
                        cy = -image.height;
                        deg = 180;
                        break;
                    case 6:
                        cw = image.height;
                        ch = image.width;
                        cy = -image.height;
                        deg = 90;
                        break;
                    case 8:
                        cw = image.height;
                        ch = image.width;
                        cx = -image.width;
                        deg = 270;
                        break;
                    default:
                        break;
                }
                canvas.width = cw;
                canvas.height = ch;
                ctx.rotate((deg * Math.PI) / 180);
                ctx.drawImage(image, cx, cy);
                img = document.createElement('img');
                img.width = cw;
                img.height = ch;
                img.addEventListener('load', (/**
                 * @return {?}
                 */
                () => {
                    callback(img);
                }));
                img.src = canvas.toDataURL('image/png');
            }
            else {
                img = image;
                callback(img);
            }
        }));
    }
}
ImageCropperComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'img-cropper',
                template: "<span class=\"ng2-imgcrop\">\n  <input\n    *ngIf=\"!settings.noFileInput\"\n    #fileInput\n    type=\"file\"\n    accept=\"image/*\"\n    (change)=\"fileChangeListener($event)\"\n  />\n  <canvas\n    #cropcanvas\n    (mousedown)=\"onMouseDown($event)\"\n    (mouseup)=\"onMouseUp($event)\"\n    (mousemove)=\"onMouseMove($event)\"\n    (mouseleave)=\"onMouseUp($event)\"\n    (touchmove)=\"onTouchMove($event)\"\n    (touchend)=\"onTouchEnd($event)\"\n    (touchstart)=\"onTouchStart($event)\"\n  >\n  </canvas>\n</span>\n"
            }] }
];
/** @nocollapse */
ImageCropperComponent.ctorParameters = () => [
    { type: Renderer2 }
];
ImageCropperComponent.propDecorators = {
    cropcanvas: [{ type: ViewChild, args: ['cropcanvas', { static: true },] }],
    fileInput: [{ type: ViewChild, args: ['fileInput', { static: false },] }],
    settings: [{ type: Input }],
    image: [{ type: Input }],
    inputImage: [{ type: Input }],
    cropper: [{ type: Input }],
    cropPosition: [{ type: Input }],
    cropPositionChange: [{ type: Output }],
    onCrop: [{ type: Output }],
    imageSet: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageCropperModule {
}
ImageCropperModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ImageCropperComponent],
                exports: [ImageCropperComponent],
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageCropperService {
    constructor() { }
}
ImageCropperService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ImageCropperService.ctorParameters = () => [];
/** @nocollapse */ ImageCropperService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ImageCropperService_Factory() { return new ImageCropperService(); }, token: ImageCropperService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// looks like this CropService is never used
class CropService {
    /**
     * @param {?} canvas
     * @return {?}
     */
    init(canvas) {
        this.canvas = canvas;
        this.ctx = (/** @type {?} */ (this.canvas.getContext('2d')));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Bounds, CornerMarker, CropPosition, CropService, CropTouch, CropperDrawSettings, CropperSettings, DragMarker, Exif, Fraction, Handle, ImageCropper, ImageCropperComponent, ImageCropperDataShare, ImageCropperModel, ImageCropperModule, ImageCropperService, Point, PointPool, ImageCropperModel as ɵa };
//# sourceMappingURL=ngx-img-cropper.js.map
